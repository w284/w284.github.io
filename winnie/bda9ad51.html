<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS246 Notes | WENLING'S BLOG</title><meta name="author" content="Winnie.zwl"><meta name="copyright" content="Winnie.zwl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Class1&#x2F;2—Input,OutputWe’ll look at OOP from three perspectives:  Programmer’s perspective: how to structure program correctly &amp; how to lower the risk of bugs The compiler’s perspective: what">
<meta property="og:type" content="article">
<meta property="og:title" content="CS246 Notes">
<meta property="og:url" content="https://w284.github.io/winnie/bda9ad51.html">
<meta property="og:site_name" content="WENLING&#39;S BLOG">
<meta property="og:description" content="Class1&#x2F;2—Input,OutputWe’ll look at OOP from three perspectives:  Programmer’s perspective: how to structure program correctly &amp; how to lower the risk of bugs The compiler’s perspective: what">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_chair.JPG">
<meta property="article:published_time" content="2024-09-05T04:00:00.000Z">
<meta property="article:modified_time" content="2024-10-22T21:35:06.761Z">
<meta property="article:author" content="Winnie.zwl">
<meta property="article:tag" content="course notes-24Fall">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_chair.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://w284.github.io/winnie/bda9ad51.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = true
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":150,"languages":{"author":"Author: Winnie.zwl","link":"Link: ","source":"Source: WENLING'S BLOG","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS246 Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 17:35:06'
}</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://cdn.statically.io/gh/w284/pictures/main/img/sky.JPG);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.statically.io/gh/w284/pictures/main/img/avatar_.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-coffee"></i><span> Leisure</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos"><i class="fa-fw fas fa-camera"></i><span> Photo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_chair.JPG);"><nav id="nav"><span id="blog-info"><a href="/" title="WENLING'S BLOG"><span class="site-name">WENLING'S BLOG</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-coffee"></i><span> Leisure</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos"><i class="fa-fw fas fa-camera"></i><span> Photo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CS246 Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-05T04:00:00.000Z" title="Created 2024-09-05 00:00:00">2024-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-22T21:35:06.761Z" title="Updated 2024-10-22 17:35:06">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/UW/">UW</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>74mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS246 Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Class1-2"><a href="#Class1-2" class="headerlink" title="Class1&#x2F;2"></a>Class1&#x2F;2</h1><p><strong>—Input,Output</strong><br>We’ll look at OOP from three perspectives:</p>
<ul>
<li>Programmer’s perspective: how to structure program correctly &amp; how to lower the risk of bugs</li>
<li>The compiler’s perspective: what does constructors actually mean &amp; what must the compiler do to support them</li>
<li>The designer’s perspective How to use OOP tools to build systems(polymorphism, inheritance, encapsulation)</li>
</ul>
<h2 id="Intro-to-C"><a href="#Intro-to-C" class="headerlink" title="Intro to C++"></a><strong>Intro to C++</strong></h2><p>Hello world in C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;Hello world&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hello world in C++:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import&lt;iostream&gt;;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; end;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notes: </p>
<ul>
<li><p><code>import</code>, like <code>#include</code>, brings name and definition from other files, libraries, or modules into our code</p>
</li>
<li><p><code>import</code>, was C++ new module system</p>
</li>
<li><p><code>#include&lt;iostream&gt;</code> works too, but module system is preferred</p>
<ul>
<li><code>#include</code> is replaced by the contents of the header directly, while <code>#import</code> is only replaced by the contents of the header the first time that header is imported*</li>
</ul>
</li>
<li><p>function<code> main()</code> MUST  return <code>int</code>, <code>void main()&#123;&#125;</code> is not valid in C++</p>
</li>
<li><p>return statement return a status code to OS ($?: check last executed program’s status code)</p>
<ul>
<li>can be omitted from main, default to return 0</li>
</ul>
</li>
<li><p><code>cout</code> and <code>&lt;&lt;</code> are how you wish to stdout</p>
<ul>
<li>this is the preferred way to do I&#x2F;O in c++</li>
<li><code>stdio.h</code> and <code>printf</code> is still available in c++</li>
</ul>
</li>
<li><p><code>using namespace std</code></p>
<ul>
<li>called a using directive</li>
<li>c++ organizes names into namespaces</li>
<li>without <code>using namespaces std</code> , you need to write <code>std:: cout &lt;&lt; &quot;Hello world &quot;&lt;&lt; std::endl&quot;</code> </li>
<li><code>std:: </code></li>
</ul>
</li>
</ul>
<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input&#x2F;Output"></a>Input&#x2F;Output</h2><p>c++ comes with 3 built-in I&#x2F;O streams:</p>
<ul>
<li><code>cout</code>: for writing to stdout</li>
<li><code>cerr</code>: for writing to stderr (never buffered)</li>
<li><code>cin</code>: for reading from stdin</li>
</ul>
<p>Built-in Operators:</p>
<ul>
<li><code>&lt;&lt; put to</code>, insertion operator(output)</li>
<li><code>&gt;&gt; get from</code> extraction operator(input)</li>
<li><code>cout &lt;&lt; __ &lt;&lt; __ &lt;&lt; __ &lt;&lt; endl;</code><ul>
<li>dates, expressions, literals</li>
<li><code>endl</code> outputs an end of line, char and flushes the output buffer</li>
</ul>
</li>
<li><code>cout &lt;&lt; x</code> operators “point” in the direction of data flow</li>
<li><code>cerr &lt;&lt; x</code></li>
<li><code>cin &gt;&gt; x</code> extract a value from stdin and put it into x</li>
</ul>
<p>Example: read 2 <code>int</code> and print their sum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &lt;iostream&gt;;</span><br><span class="line">using namespace std;</span><br><span class="line">int mian()&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ul>
<li>the <code>&gt;&gt;</code> operator tries to interpret the input data according to the type of variable<ul>
<li>in this case, x as an <code>int</code>, so <code>&gt;&gt;</code> will expect to read chars that look like an <code>int</code> like <code>123</code> or <code>-42</code> and assemble those chars into a <strong>value</strong> </li>
<li>it will stop reading when it sees characters that is not part of an integer(letter or space)</li>
<li><code>cin &gt;&gt;</code>ignores leading whitespaces(spaces, tabs, newlines)</li>
<li>when reading from the keyboard, the program will pause waiting for the user input</li>
<li>pressing Enter causes the entered text to be submitted to the program (with \n)</li>
<li>Pressing ^D signals end of file, or end of input (without \n)</li>
</ul>
</li>
</ul>
<p> What if bad things happened?<br>    - input doesn’t contain an <code>int</code><br>    - input is too large&#x2F;small to fit in the variable<br>    - input is exhausted(not enough input&#x2F;data, i.e EOF) and get 2 int</p>
<p>The input operation fails, how can we test for this in our program?<br>    - if read failed(for whatever reason), <code>cin.fail()</code> return true<br>    - if EOF: <code>cin:eof()</code> will return true<br>    - But not until attempted read fails </p>
<p>Example: read all int from <code>stdin</code>, echo to <code>stdout</code>, one per line, stop at EOF or bad input</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		cin &gt;&gt; i;</span><br><span class="line">		if(cin.fail()) break;  // checking for failure</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		cin &gt;&gt; i;</span><br><span class="line">		if(!cin) break; //cin variable is implicitly converted to a boolean value</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cin</code> converts to:</p>
<ul>
<li><code>true</code> if all good</li>
<li><code>false</code> if the stream has had a read failure</li>
</ul>
<p>Let’s take a closer look at &#x3D;&#x3D;<code>&gt;&gt; </code>operator:&#x3D;&#x3D;</p>
<ul>
<li><p><code>&gt;&gt;</code> is C’s (and c++’s) right bitshift operator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if a, b are ints, a &gt;&gt; b shifts a&#x27;s bits to the right by b spots</span><br><span class="line">Eg:</span><br><span class="line">21 &gt;&gt; 3</span><br><span class="line">	= 2</span><br><span class="line">// 21 = 10101</span><br><span class="line">//2 = 10</span><br></pre></td></tr></table></figure>

</li>
<li><p>the <code>&gt;&gt;</code> operator has two operants </p>
<ul>
<li><code>cin</code> which is a stream</li>
<li>a variable to receive the input data , in our example;</li>
</ul>
</li>
<li><p>and it returns a result:</p>
<ul>
<li><code>cin</code> the same stream used as the first operand</li>
<li>it also has side effect</li>
</ul>
</li>
<li><p>the fact that it returns a stream, is why we can chain a series of those together</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z</span><br><span class="line">[cin &gt;&gt; x] -&gt; cin</span><br><span class="line">  = cin &gt;&gt; y &gt;&gt; z</span><br><span class="line">   [cin &gt;&gt; y] -&gt; cin</span><br><span class="line">      = cin &gt;&gt; z</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Example 3: getting input and output to the screen </span><br><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if(!(cin &gt;&gt; i)) break; //reading int i and checking for failure</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Example 4: </span><br><span class="line">int main()&#123;</span><br><span class="line">  int i;</span><br><span class="line">  while(cin &gt;&gt; i)&#123; // if we cannot get anymore input, then cin &gt;&gt; i is false</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Example 5: Read all from stdin, echo to stdout until EOF, skip non-integer input </span><br><span class="line">Version 1:</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if (cin &gt;&gt; i) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; endl; // will be default printed as a decimal</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cin.eof()) break; // Done - EOF</span><br><span class="line">		cin.clear(); // Read the stream&#x27;s failure flag.The stream will not  function after failure until it do so </span><br><span class="line">		cin.ignore(); // Removes the offending character from the stream</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Version2:</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(true)&#123; </span><br><span class="line">		// if false, then something bad happened -&gt; EOF, bad input</span><br><span class="line">		if (!(cin &gt;&gt; i))&#123;</span><br><span class="line">			if (cin.eof()) break;</span><br><span class="line">			cin.clear();</span><br><span class="line">			cin.ignore();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ul>
<li><code>clear()</code> must come before <code>ignore()</code>. Called <code>ignore()</code> on a failed stream does nothing.</li>
<li><code>ignore()</code> removes 1 char from the stream</li>
<li><code>ignore(count)</code> removes count chars from stream</li>
<li><code>ignore(count &#39;\n&#39;)</code>  removes count chars <strong>or</strong> everything up to and including newline character, whatever comes first</li>
</ul>
<h2 id="Formatted-Output"><a href="#Formatted-Output" class="headerlink" title="Formatted Output"></a>Formatted Output</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; 95 &lt;&lt; endl; //default print in decimal</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; endl; //print 95 as a hex (manipulator)</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; 15 &lt;&lt; endl; // gets printed out in hex until you set it back to decimal cout &lt;&lt; dec &lt;&lt; 15 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>Many properties are controlled by some global flag, can find them by → more <a target="_blank" rel="noopener" href="http://manip.cc/">manip.cc</a> in terminal → more <a target="_blank" rel="noopener" href="http://conversionchart.cc/">conversionChart.cc</a></em></li>
</ul>
<p><code>hex</code>: I&#x2F;O manipulator, put the stream into “hex mode”, all subsequent ints are printed in hex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dec; //switch stream back to decimal mode</span><br></pre></td></tr></table></figure>

<p><strong>Example: print a dollar amount</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &lt;iostream&gt;;</span><br><span class="line">import &lt;iomanip&gt;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	double m = 10.9;</span><br><span class="line">	//cout &lt;&lt; setprecision(5) &lt;&lt; 10.356278 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; setw(10) &lt;&lt; setfill(&#x27;*&#x27;) &lt;&lt; right &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Prints: <code>xxxxx10.90</code>(10 characters)<br><code>fixed</code> : output fixed character of decimal places<br>Note:</p>
<ul>
<li>use <code>import &lt;iomanip&gt;</code></li>
</ul>
<h1 id="Class2"><a href="#Class2" class="headerlink" title="Class2"></a>Class2</h1><p><strong>—string, file access</strong></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>C strings: An array of <code>char</code> (<code>char * </code> or <code>char[]</code> ) terminated by a null char <code>\0</code></p>
<ul>
<li>must explicitly manage memory - allocate memory as strings get bigger</li>
<li>easy to overwrite the <code>\0</code> at the end</li>
<li>one of the biggest sources of security vulnerability</li>
</ul>
<p>C++ strings: built-in string data type</p>
<ul>
<li>import <code>&lt;string&gt;</code></li>
<li>intuitive, easy-to-use</li>
<li>string grow as needed(no need to explicitly manage memory)</li>
<li>safer to manipulate</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;Hello&quot;;</span><br><span class="line">string s2 = &quot;World&quot;;</span><br><span class="line">string s3 = s1 + &quot; &quot; + s2; //concat, s3 needs to be defined already</span><br></pre></td></tr></table></figure>
<h2 id="String-operations"><a href="#String-operations" class="headerlink" title="String operations:"></a>String operations:</h2><ul>
<li>equality&#x2F;inequality: <code>== </code> <code>!=</code>  <code>s1 == s2 | s1 != s2</code><ul>
<li>–&gt; comparing strings NOT memory addresses</li>
</ul>
</li>
<li>comparisons: <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> etc. (lexicographic by default)</li>
<li>length: <code>s.length()</code> note this is O(1) –&gt; string structure stores string length</li>
<li>concat:<br>   <code>s3 = s1 + s2;</code><br>   <code>s3 += s4;</code></li>
<li>individual char:<br>  <code>s[0] // first character</code><br>  <code>s[1] // second character</code></li>
<li>mutable:<ul>
<li><code>s[0] = &#39;h&#39;;</code></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s; // skip leading whitespaces, stop at reading white space.</span><br></pre></td></tr></table></figure>
<p>what if we want the white space?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(cin, s); // getline(stream, stringvariable name) </span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">cin.get(c);</span><br><span class="line">while(cin.get(c))&#123;</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getine(cin, s)</code>Read from current position, up to the next new line character <code>\n</code> into s, excluding <code>\n</code></li>
<li>stream is a abstraction</li>
</ul>
<h2 id="File-Streams"><a href="#File-Streams" class="headerlink" title="File Streams:"></a>File Streams:</h2><ul>
<li>read&#x2F;write from&#x2F;to a file instead of stdin&#x2F;stdout</li>
<li><code>std::ifstream</code>: a file stream for reading</li>
<li><code>std::ofstream</code>: a file stream for writing</li>
<li>must import <code>&lt;fstream&gt;</code></li>
</ul>
<p>File access in C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	FILE *f = fopen(&quot;file.text&quot;, &quot;r&quot;);</span><br><span class="line">	char s[256];</span><br><span class="line">	while(1) &#123;</span><br><span class="line">		fscan(f, &quot;%255s&quot;, s);</span><br><span class="line">		if(feof(f)) break;</span><br><span class="line">		printf(&quot;%s\n&quot;, s);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File access in C++:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &lt;iostream&gt;;</span><br><span class="line">import &lt;fstream&gt;;</span><br><span class="line">import &lt;string&gt;;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    //Declare and initialize the file variable f, and opens the file</span><br><span class="line">	ifstream f &#123;&quot;file.txt&quot;&#125;;</span><br><span class="line">	string s;</span><br><span class="line">	while(f &gt;&gt; s)&#123;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//file is closed automatically when the f variable goes out of space </span><br></pre></td></tr></table></figure>
<h1 id="Class-3"><a href="#Class-3" class="headerlink" title="Class 3"></a>Class 3</h1><p><strong>—string stream, overload, struct</strong></p>
<p>Recall</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &lt;iostream&gt;;</span><br><span class="line">import &lt;fstream&gt;;</span><br><span class="line">import &lt;string&gt;;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	// Declaring + Initializing the istream variable f opens the file</span><br><span class="line">	ifstream f &#123;&quot;file.txt&quot;&#125;; </span><br><span class="line">	string s;</span><br><span class="line">	while (f &gt;&gt; s) &#123;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; // file is closed when f goes out of scope</span><br></pre></td></tr></table></figure>

<ul>
<li>where does the OS open and close file happen? <ul>
<li>Declaring + Initializing the <code>istream</code> variable <code>f</code> opens the file <code>ifstream f &#123;&quot;file.txt&quot;&#125;; </code></li>
<li>variable has scope, so  file is closed when f goes out of scope</li>
</ul>
</li>
<li>Anything you can do with <code>cin</code> and <code>cout</code>, you can do with an <code>ifstream </code> and <code>ofstream</code></li>
</ul>
<h2 id="String-Stream"><a href="#String-Stream" class="headerlink" title="String Stream"></a>String Stream</h2><ul>
<li>Extract data from chars in a string: <code>std::istringstream</code></li>
<li>Send data to string as chars: <code>std::ostringstream</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Example1: convert # to string</span><br><span class="line">//easiest way to convert # to string is to print the # into string</span><br><span class="line">import &lt;sstream&gt;;</span><br><span class="line">string intToString (int n) &#123;</span><br><span class="line">	ostringstream sock; //stream that writes to a string</span><br><span class="line">	sock &lt;&lt; n;</span><br><span class="line">	return sock.str(); //extract the string</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Example2: convert string to #</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Enter a number&quot; &lt;&lt; endl;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		// scope the isstringstream variable sock in if()</span><br><span class="line">		if(istringstream sock &#123;s&#125;; sock &gt;&gt; n) break;</span><br><span class="line">		cout &lt;&lt; &quot;I said, &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;You entered&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Example revisited: Echo all #&#x27;s, skip all non-#&#x27;s</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	while(cin &gt;&gt; s)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		if(isstringstream sock&#123;s&#125;; sock &gt;&gt; n) cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Note: </p>
<ul>
<li><p><code>if(isstringstream sock&#123;s&#125;; sock &gt;&gt; n)</code> , here <code>sock &gt;&gt; n</code> could fail, but we don’t have to do the <code>sock.clear()</code> and <code>sock.ignore()</code>, we don’t have to worry about renewing it here cuz it is under the scope of <code>if()</code>, every loop the stream is a new one</p>
</li>
<li><p><code>abc123</code> <code>456def789</code></p>
</li>
</ul>
<h2 id="Application-processing-the-command-line"><a href="#Application-processing-the-command-line" class="headerlink" title="Application: processing the command line"></a>Application: processing the command line</h2><p>To accept cmd line args in C or C++, always give main the following parameters</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;...&#125;</span><br><span class="line">//argc: # of command line arguments(&gt;=1 cuz it includes the program name itself)</span><br><span class="line">//argv: array of c-style strings</span><br><span class="line">	arg[0] = program name</span><br><span class="line">	arg[1] = first arg</span><br><span class="line">	...</span><br><span class="line">	arg[argc] = null(the null terminator)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg.:</span><br><span class="line">./myprogram abc 123</span><br><span class="line">args = 3</span><br><span class="line">argv = </span><br><span class="line">|.|/|m|y|p|r|o|g|r|a|m|\0|</span><br><span class="line">|a|b|c|\0|</span><br><span class="line">|1|2|3|\0|</span><br><span class="line">|\|</span><br><span class="line"></span><br><span class="line">//these are C-Style Strings!!</span><br></pre></td></tr></table></figure>

<p><strong>Recommendations</strong> : convert to C++ style strings before processing<br>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">	for(int i = 1; i &lt;argc; i++)&#123;</span><br><span class="line">		string arg = argc[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example: print the sum of all numeric args on the cmd line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main (int argc, char * argv[])&#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	for (int i = 1; i &lt; argc; i++)&#123;</span><br><span class="line">		string arg = argv[i];</span><br><span class="line">		int n;</span><br><span class="line">		if(istringstream sock&#123;arg&#125;; sock &gt;&gt; n) sum += n;</span><br><span class="line">		//echo # only</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Default-Function-Parameters"><a href="#Default-Function-Parameters" class="headerlink" title="Default Function Parameters"></a>Default Function Parameters</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void printFile(string name = &quot;file.txt&quot;)&#123;// default value is file.txt</span><br><span class="line">	ifstream f&#123;name&#125;;</span><br><span class="line">	for(string s; f &gt;&gt; s) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// run program by writing: </span><br><span class="line">printFile(); //print from file.txt</span><br><span class="line">printFile(&quot;myfile.txt&quot;); // will be executed with myfile.txt</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>optional parameters must be last</li>
<li><code>int f(int n = 2, int y = 3, int z = 4) &#123; &#125;</code><ul>
<li><code>f(0)</code> → <code>f(0, 3, 4)</code></li>
<li><code>f(1, 2)</code> → <code>f(1, 2, 4)</code></li>
<li><code>f()</code> → <code>f(2, 3, 4)</code></li>
</ul>
</li>
<li>The missing parameter is supplied by the caller, not the function<ul>
<li>Why? <ul>
<li>The caller passes parameters by pushing them onto the stack</li>
<li>The function fetches the parameters by reading them from the stack from where they are expected to be</li>
<li>If an argument is missing, the function has no way of knowing that (cuz it fetches from the stack position) —&gt; so the function would interpret whatever is in that position of the stack as the arg</li>
</ul>
</li>
<li>So the <strong>caller</strong> must supply the extra parameter if it is missing</li>
<li>–&gt; When you write <code>printFile();</code> the <strong>compiler</strong> replaces with <code>printFile(&quot;file.txt&quot;);</code></li>
</ul>
</li>
<li>For the above reason, default arguments are part of a function’s <strong>interface</strong>, rather than its <strong>implementation</strong></li>
<li>If you are doing separate compilation, defaults go in the interface file, not the implementation file</li>
</ul>
<h2 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h2><p>Think of negate in C, apply negate to int, bool, needs two different functions<br>C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int negInt(int n )&#123;return -n;&#125;</span><br><span class="line">int negBool(bool b)&#123;return !b&#125;;</span><br></pre></td></tr></table></figure>

<p>whereas,<br>C++:<br>Functions with different parameter lists can share the same name(different # of parameters &#x2F; different types)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//called overloading</span><br><span class="line">int neg(int n) &#123;return -n&#125;;</span><br><span class="line">bool neg(bool b) &#123;return !b&#125;; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Compiler</strong> chooses the correct version of neg for each function call based on  # and type of args in the function call -&gt; done at <strong>compile time</strong> </li>
<li>overloads must differ in # or types of arguments –&gt; just different in the return type is <strong>not</strong> enough</li>
</ul>
<p>We’ve seen this already:</p>
<ul>
<li><code>&gt;&gt;</code> , <code>&lt;&lt;</code> <code>+</code> are overloaded</li>
<li>behaviour depends on types of args</li>
</ul>
<h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node *next; </span><br><span class="line">	//in C it has to say struct Node *next</span><br><span class="line">	//in C++ we don&#x27;t have to say struct Node *next</span><br><span class="line">&#125;;</span><br><span class="line">//Don&#x27;t forget the semicolon</span><br><span class="line">//we got this from the designer of C</span><br></pre></td></tr></table></figure>

<p>we are allowed to do</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">...</span><br><span class="line">&#125; n1, n2, n3; //n1 n2 n3 is in local scope</span><br><span class="line">//we can create variables with struct, that&#x27;s the purpose of the semi-colon</span><br></pre></td></tr></table></figure>

<p>Why is this wrong?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This says every node has a node <strong>in</strong> it</p>
<h2 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h2><p><code>const int passingGrade = 50;</code> const must be initialized</p>
<ul>
<li>Declare as many constants as you can - it helps catch errors</li>
</ul>
<p>Node n {5, nullptr}; -<code>nullptr</code> is syntax for null pointer in C++</p>
<ul>
<li>Do not say NULL or 0 in this class!</li>
</ul>
<h1 id="Class-4"><a href="#Class-4" class="headerlink" title="Class 4"></a>Class 4</h1><p><strong>—constant, parameter passing, reference, dynamic memory</strong></p>
<h2 id="Constants-1"><a href="#Constants-1" class="headerlink" title="Constants"></a>Constants</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node n &#123;5, nullptr&#125;, // Do not say NULL, use nullptr instead in C++</span><br></pre></td></tr></table></figure>
<ul>
<li>why?<ul>
<li>imagine overload  <code>void f(int n)</code> <code>void f(int *p)</code> </li>
<li>what does <code>f(NULL)</code> mean then? </li>
<li>So we have <code>nullptr</code> that is never a number in C++</li>
</ul>
</li>
</ul>
<p><code>const Node n2 = n \\ immutable copy of n</code></p>
<h2 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void inc (int n)&#123; ++n;&#125; </span><br><span class="line">int x = 5;</span><br><span class="line">inc(x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; // We get 5 here</span><br><span class="line">//Pass-by-value</span><br><span class="line">//inc gets a copy of x, mutates the copy doesn&#x27;t chang the original </span><br></pre></td></tr></table></figure>

<p>Solution:<br>If a function needs to mutate an arg, pass a ptr</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void inc(int *n)&#123;++*n;&#125;</span><br><span class="line">int x = 5;</span><br><span class="line">inc(&amp;x); //x&#x27;s address</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; //6 --visible to the caller</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Q: Why <code>cin &gt;&gt; x</code> and not <code>cin &gt;&gt; &amp;x</code> ?<br>A: C++ has another ptr-like type — references<br><strong>References</strong> - important </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int y = 10;</span><br><span class="line">int &amp;z = y; </span><br><span class="line"></span><br><span class="line">// z is an lvalue reference to y</span><br><span class="line">// like a const ptr - similar to int *const z = &amp;y</span><br><span class="line">//z is pointing at y in a way that it can&#x27;t point anywhere else (constant ptr)</span><br></pre></td></tr></table></figure>

<p>Refs are like const ptrs with <strong>automatic dereferencing</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = 12 (NOT *z = 12) // Now y = 12 !!(mutated)</span><br><span class="line">int *p = &amp;z --&gt; gives the address of y</span><br></pre></td></tr></table></figure>
<p>In all cases, <code>z</code> behaves exactly like <code>y</code>, <code>z</code> is an alias (“another name”) for <code>y</code></p>
<p>Q: How can we tell when <code>&amp;</code> means “reference” and when it means “address of” ?<br>A:Whenever <code>&amp;</code> occurs as part of a <strong>type</strong> (eg. <code>int &amp;z</code>), it always means reference<br>When <code>&amp;</code> occurs in an <strong>expression</strong>, it means “address of” (or bitewise-end).</p>
<p><strong>Things you can’t do with lvalue refs:</strong><br><em>lvalue:</em><br><code>x=y</code>, <em>on the right hand side we care about the value(rvalue), on the left hand side we are interested in the location(lvalue); const can be considered lvalue to0; lvalue has to be something that denotes an address;</em></p>
<p><strong>Things can’t do:</strong></p>
<ul>
<li>leave them <strong>uninitialized</strong> (e.g. <code>int &amp;x</code>)<br>  must be initialized with something that has an <strong>address(an lvalue)</strong> since refs are ptrs<br>   <code>int &amp;x = 3; //doesn&#39;t work, it doesn&#39;t have an address</code><br>   <code>int &amp;x = y + z;</code><br>   <code>int &amp;x = y;</code></li>
<li>create a <strong>ptr to a reference</strong>: <ul>
<li><code>int &amp;*p;// p is a ptr to the reference to an int, illgeal</code></li>
<li>ref to ptr OK: <code>int *&amp; p; //legal</code></li>
</ul>
</li>
<li>create a <strong>ref to a ref</strong>: <code>int &amp;&amp;r = ... //ilegall</code><ul>
<li>this means sth different (later)</li>
</ul>
</li>
<li>create an <strong>array of refs</strong> : <code>int &amp;r[]=&#123;_,_,_&#125;;  //illegal</code></li>
</ul>
<h3 id="What-you-can-do"><a href="#What-you-can-do" class="headerlink" title="What you can do:"></a>What you can do:</h3><p><strong>Pass as function parameters</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void inc(int &amp;n) &#123;++n; //no ptr dereference&#125;</span><br><span class="line">//&amp;n is a const ptr to the arg (x), thus change will affect x</span><br><span class="line"></span><br><span class="line">int x = 5;</span><br><span class="line">inc(x);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; //6</span><br></pre></td></tr></table></figure>
<p><strong>Why does <code>cin &gt;&gt; x</code> work?</strong><br>Take x as a reference<br><code>istream &amp; operator &gt;&gt; (istream &amp;in, int &amp;x);</code><br>Q: Why is the stream being taken of returned as a ref? And what does returning by ref mean?<br>A: Need a better understanding of the cost of parameter passing </p>
<p>Pass-by-value<br><code>eg: int f(int n)&#123;...&#125; copies the arg, if the arg is big, copy is expensive</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">struct ReallyBig&#123;...&#125;;</span><br><span class="line">int f(ReallyBig rb)&#123;...&#125; //This is a copy---slow </span><br><span class="line">int g(ReallyBig &amp;rb)&#123;...&#125; //an alias, fast, But could change rb in the caller</span><br><span class="line">int n(const ReallyBig &amp;rb)&#123;...&#125; //-fast -no copy -param cannot be change</span><br></pre></td></tr></table></figure>
<p><strong>Pick reference over pointers:</strong></p>
<ul>
<li>Const - can’t change where the reference points to</li>
<li>Reference can never be NULL - no need to worry</li>
</ul>
<p>What if a function does want to make changes to <code>rb</code> locally, but does not want these changes visible to the caller?</p>
<ul>
<li>Then the function must make a local copy of <code>rb</code>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int k (const ReallyBig &amp;rb)&#123;</span><br><span class="line">	ReallyBig rb2 = rb;</span><br><span class="line">	//mutate rb2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>But if you have to make a copy anyway, it’s better to just use pass-by-value and have the compiler make it for you –maybe it can optimize something</li>
<li><strong>Advice:</strong> </li>
<li>Prefer pass-by-const-ref over pass-by-value for anything larger than a ptr, unless the function needs to make a copy anyway–then use pass-by-value</li>
<li><strong>Also</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int f(int &amp;n);   int g(const int &amp;n);</span><br><span class="line"></span><br><span class="line">f(5); //illegal</span><br><span class="line">//can&#x27;t initialize an lvalue ref(n) to a literal value (non-lvalue)</span><br><span class="line">//if n changes, can&#x27;t change the literal 5</span><br><span class="line"></span><br><span class="line">g(5); //OK</span><br><span class="line">//since ref(n) can never be changed, the compiler allows this</span><br></pre></td></tr></table></figure>
How? (important):</li>
<li>for as long as g is running, 5 is in stack, there is a place to point at</li>
<li>the 5 is stored in a temporary location(stack)</li>
<li>ref has something to point to<br>–&gt; so, putting const makes function more applicable</li>
</ul>
<p><strong>So, in the case of</strong><br><code>istream &amp;operator &gt;&gt; (istream &amp;in, int &amp;x);</code><br>the <code>istream</code> is passed and <strong>returned by reference</strong> to save copying;<br>This is important, because stream variables are not allowed to be copied</p>
<h2 id="Dynamic-Memory"><a href="#Dynamic-Memory" class="headerlink" title="Dynamic Memory"></a>Dynamic Memory</h2><p>C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p = malloc(__* sizeof(int));</span><br><span class="line">...</span><br><span class="line">free (p);</span><br></pre></td></tr></table></figure>
<p>Don’t use these in C++!!<br>Instead: new&#x2F;delete<br><strong>new&#x2F;delete</strong></p>
<ul>
<li>type-aware</li>
<li>less error-prone</li>
<li>eg:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;...&#125;;</span><br><span class="line">Node *np = new Node;</span><br><span class="line">...</span><br><span class="line">delete np;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">All local variables reside on the stack</span><br><span class="line">- variables deallocates when they got out of the scope(stack is popped)</span><br><span class="line">- Allocated memory resides on the heap</span><br><span class="line">- remains allocated until delete is called</span><br><span class="line">	- if don&#x27;t delete all manually --&gt; Memory Leak</span><br></pre></td></tr></table></figure>


<h1 id="Class-5"><a href="#Class-5" class="headerlink" title="Class 5"></a>Class 5</h1><p><strong>—return value, operator overload</strong></p>
<h2 id="Dynamic-Memory-Recall"><a href="#Dynamic-Memory-Recall" class="headerlink" title="Dynamic Memory Recall:"></a>Dynamic Memory Recall:</h2><p>Dynamic <strong>memory allocation</strong>:<br>C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p = malloc(10*sizeof(int));</span><br><span class="line">p[0]=10;</span><br><span class="line">p[1]=20;</span><br><span class="line">free(p); //dangling pointer</span><br><span class="line">p = NUll; //clear p so it doesn&#x27;t have a value anymore</span><br></pre></td></tr></table></figure>
<p>C++:<br>using <strong>new &#x2F; delete</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int; //create an int obejct on the heap, return a pointer to it</span><br><span class="line">//for pointer</span><br><span class="line">*p = 10;</span><br><span class="line">delete p; //deallocate the memory of the int, p is still a &quot;dangling pointer&quot;</span><br><span class="line">p = nullptr;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node *np = new Node; //create a node object on the heap and return a pointer</span><br><span class="line">//np is stored in the stack and the node np points to is in the heap</span><br><span class="line">np-&gt;data = 42;</span><br><span class="line">(*np).data = 42;</span><br><span class="line">delete np; //Deallocate the memory, np is a dangling pointer</span><br><span class="line"></span><br><span class="line">main memory:</span><br><span class="line">----------------------</span><br><span class="line">operating syestem</span><br><span class="line">and other programs</span><br><span class="line">----------------------</span><br><span class="line">your program                   </span><br><span class="line">----------------------            </span><br><span class="line">memory available to      </span><br><span class="line">the prorgam                         </span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure>

<ul>
<li>All local variables are <strong>function parameters</strong> reside on the stack<ul>
<li>variables deallocates automatically when they got out of the scope(stack is popped)</li>
<li>if they are pointers, the memory they point to is not deallocated automatically</li>
</ul>
</li>
<li>Memory allocated with <strong>new</strong> resides on the heap<ul>
<li>remains allocated until you call delete</li>
<li>if you don’t delete all allocated memory –&gt; memory leak(this is an incorrect program)</li>
</ul>
</li>
<li>Calling <strong>delete</strong> on the same pointer more than once is an error<ul>
<li>program will crash: SEGV</li>
</ul>
</li>
<li>Calling delete on a <code>nullptr</code> is harmless - safe and acceptable</li>
<li>Never call <strong>delete</strong> on a stack-allocated object –&gt; program<ul>
<li>will crash</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ex:</span><br><span class="line">Node n;</span><br><span class="line">...</span><br><span class="line">Node *p = &amp;n;</span><br><span class="line">...</span><br><span class="line">delete p; //this causes a crash</span><br></pre></td></tr></table></figure>

<h2 id="Returning-Values-From-Functions"><a href="#Returning-Values-From-Functions" class="headerlink" title="Returning Values From Functions"></a>Returning Values From Functions</h2><p><strong>Bad ways:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Return by value:</span><br><span class="line">	Node getMeANode()&#123;                    </span><br><span class="line">		Node n;      ---&gt; stack for getMeANode()</span><br><span class="line">		...</span><br><span class="line">		return n;           </span><br><span class="line">	&#125;</span><br><span class="line">	----</span><br><span class="line">	copy</span><br><span class="line">	----</span><br><span class="line">	Node n1 = getMeANode(); ----&gt; stack for the calling function</span><br><span class="line"></span><br><span class="line">Return by pointer:</span><br><span class="line">Node *getMeANode()&#123;</span><br><span class="line">  Node n;</span><br><span class="line">  ...</span><br><span class="line">  return &amp;n;</span><br><span class="line">&#125;</span><br><span class="line">Node &amp;n1 = getMeANode();</span><br><span class="line">//BAD! We are returning a pointer to stack-allocated data, which is dead on return </span><br><span class="line"></span><br><span class="line">Return by Reference:</span><br><span class="line">Node &amp;getMeANode()&#123;</span><br><span class="line">	Node n;</span><br><span class="line">	...</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">Node &amp;n1 = getMeANode(); //Also Bad</span><br><span class="line">stack:</span><br><span class="line">n1: n: | __ |</span><br></pre></td></tr></table></figure>



<p>reference doesn’t have a value on its on, just an alias to an object<br><strong>HOWEVER:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Recall the &gt;&gt; operator </span><br><span class="line">istream &amp; operator &gt;&gt; (istream &amp;in, int &amp;n)&#123;</span><br><span class="line">	...</span><br><span class="line">	//Reads chars from input stream, inteprets them as an integer, and puts</span><br><span class="line">	//the value into n</span><br><span class="line">	...</span><br><span class="line">	return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Why is it okay to return a reference here? <code>istream &amp;operator&gt;&gt;(istream &amp;in, int &amp;n)</code><ul>
<li>main: <code>cin &gt;&gt; n</code></li>
<li>the argument <code>istream &amp;in</code> was already available to the caller of <code>operator &gt;&gt;</code> so returning a reference back to it is okay</li>
<li><code>cin</code> and <code>n</code> are in main so when you return the <code>istream</code>, you are returning it in <code>main</code>, not out of scope when <code>istream</code> is finished</li>
</ul>
</li>
</ul>
<h3 id="Correct-Way"><a href="#Correct-Way" class="headerlink" title="Correct Way"></a>Correct Way</h3><p><strong>Return by Pointer(fixed):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node *getMeANode()&#123;</span><br><span class="line">  Node *np = new Node;</span><br><span class="line">  ...</span><br><span class="line">  return np;</span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = getMeANode();</span><br></pre></td></tr></table></figure>
<p>This version <strong>transfers ownership</strong> of that allocated memory to the caller of the function. The caller is responsible for calling <strong>delete</strong> (or transfer ownership to some other function).</p>
<h2 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading:"></a>Operator Overloading:</h2><p>Allows us to use the built-in C++ operators with user-defined types we create:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct Vec&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec operator+(const Vec &amp;v1, const Vec &amp;v2) &#123; </span><br><span class="line">	// function won&#x27;t change the values of the thing you are pointing to and </span><br><span class="line">	// can&#x27;t change what it is pointing to because of &amp;v1 </span><br><span class="line">	Vec v&#123;v1.x + v2.x, v1.y + v2.y&#125;; </span><br><span class="line">	return v; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vec operator*(const Vec &amp;v1, const int k)&#123;</span><br><span class="line">	return &#123;v1.x * k, v1.y * k&#125;; //Alternate syntax</span><br><span class="line">	//compiler knows it&#x27;s a Vec because of the return type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec v1 = &#123;1,2&#125;;</span><br><span class="line">Vec v2 = &#123;3,4&#125;; </span><br><span class="line">Vec v3 = v1 + v2;  //uses the operator + function</span><br><span class="line">Vec v4 = v1 * 10;  //uses the operator * function</span><br><span class="line">Vec v5 = 10 * v1; //Does NOT work YET!  (i)</span><br><span class="line">Vec v6 = (v1 + v2) * 10; //works, changing them together</span><br><span class="line">//can&#x27;t change the precedence of how the operation takes place</span><br><span class="line">//without paratheses v2 * 10 will be operated first </span><br><span class="line">//ORDER MATTERS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fix (i)</span><br><span class="line">Vec operator*(const int k, const Vec v)&#123;</span><br><span class="line">	return v * k;  //Reusing a function already defined </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vec v3 = operator + (v1,v2); //This works too</span><br></pre></td></tr></table></figure>

<p>We can also overload <code>&gt;&gt;</code> and <code>&lt;&lt;</code> operators:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//to output a vector</span><br><span class="line">cout &lt;&lt; v1; //(1,2) desired output format</span><br><span class="line">ostream &amp; operator &lt;&lt; (ostream &amp;out, const Vec &amp;v)&#123;</span><br><span class="line">	out &lt;&lt; &#x27;(&#x27; &lt;&lt; v.x &lt;&lt; &#x27;,&#x27; &lt;&lt; v.y &lt;&lt; &#x27;)&#x27;; //endl means newline</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//to read a vector</span><br><span class="line">istream &amp; operator &gt;&gt; (istream &amp;in, Vec &amp;v)&#123; //can&#x27;t be const, need to update &amp;v</span><br><span class="line">	char p1, c, p2; //the format of vector we&#x27;re gonna read</span><br><span class="line">	int x, y;</span><br><span class="line">	in &gt;&gt; p1 &gt;&gt; x &gt;&gt; c &gt;&gt; y &gt;&gt; p2;</span><br><span class="line">	//check the data was formatted correctly</span><br><span class="line">	if(!in.fail() &amp;&amp; p1==&#x27;(&#x27; &amp;&amp; c==&#x27;,&#x27; &amp;&amp; p2==&#x27;)&#x27;)&#123;</span><br><span class="line">		v.x = x;</span><br><span class="line">		v.y = y; //update our vector parameter</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Vec v;</span><br><span class="line">	cin &gt;&gt; v;</span><br><span class="line">	cout &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Class-6"><a href="#Class-6" class="headerlink" title="Class 6"></a>Class 6</h1><p><strong>—modules, classes, methods, MIL</strong></p>
<h2 id="Modules-and-Separate-Compilation"><a href="#Modules-and-Separate-Compilation" class="headerlink" title="Modules and Separate Compilation"></a>Modules and Separate Compilation</h2><p>we can split programs into multiple modules, where each module provides both:</p>
<ul>
<li>an interface:<ul>
<li>type definition</li>
<li>prototype for functions</li>
<li>similar to <code>.h</code> class</li>
</ul>
</li>
<li>an implementation:<ul>
<li>full definitions for every provided function</li>
<li>similar to <code>.cc</code> class</li>
</ul>
</li>
</ul>
<p>File 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example using Vec class from last class:</span><br><span class="line">//interface(vector.cc)</span><br><span class="line"></span><br><span class="line">export module vector;  //indicates that this is THE module interface file(can only be one,one per module)</span><br><span class="line"></span><br><span class="line">export struct Vec&#123; //anything marked export is available for the client of the module to use</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export Vec operator + (const Vec &amp;v1, const Vec &amp;v2); //function prototypes</span><br><span class="line">export Vec operator * (const Vec &amp;v, const int k);</span><br><span class="line">export ...</span><br></pre></td></tr></table></figure>

<p>File 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//implementation(vector-imple.cc)</span><br><span class="line"></span><br><span class="line">module vector; //This file is part of module vector</span><br><span class="line">//can have multiple implementation files per module</span><br><span class="line"></span><br><span class="line">Vec operator + (...)&#123;...&#125; //function implementations</span><br><span class="line">Vec operator * (...)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>File 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//client(main.cc)</span><br><span class="line">import vector; //import the module; Note no &lt;&gt; (this is a user module, not a system module)</span><br><span class="line"></span><br><span class="line">int main ()&#123;</span><br><span class="line">	Vec v1&#123;1,2&#125;;</span><br><span class="line">	v1 = v1 + v1;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ul>
<li>interface file start with<code> export module ___</code></li>
<li>implementation file start with <code>module ___</code></li>
<li>client file use <code>import___</code></li>
<li>These lines must be the first lines(can only be precedence by comments)</li>
</ul>
<p><strong>compiled separately and is dependency order</strong><br>    <code>g++20 -c vector.cc</code> &#x2F;&#x2F; complied module interface -&gt; <code>gcm.cache</code><br>    <code>g++20 -c vector-impl.cc</code> &#x2F;&#x2F; implementations can be compiled in either order<br>    <code>g++20 -c main.cc</code> &#x2F;&#x2F;</p>
<p><code>-c</code> &#x3D; compile only, do not link, do not create an executable, produces an object file(<code>.o</code>)</p>
<p><strong>Link and create executable:</strong><br>    <code>g++20 vector-impl.o main.o -o main</code> &#x2F;&#x2F;omit <code>vector.o</code>, the compiler goes to <code>gcm.cache</code> to find the details<br>Notes:</p>
<ul>
<li>must compile in dependency order</li>
<li>build tool support for compiling in dependency order(e.g. <code>make</code>)-is still a work in progress</li>
<li>must compile the interface file(unlike header file, you will never ever compile header file)</li>
<li>must always compile system libraries&#x2F;modules first</li>
</ul>
<p>Example of modules with multiple implementation files in: …&#x2F;lectures&#x2F;05-separate</p>


	<div class="row">
    <embed src="/pictures/924cs246.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p>A –&gt; B means A <strong>depends on</strong> B. If we were compiling we would need to compile B first </p>
<p><strong>Benefits of modules over header files:</strong></p>
<ul>
<li>faster compilation</li>
<li>if a module A imports module B to use as part of its implementations, the module B constants are <strong>not</strong> exported to the clients of module A</li>
<li>modules can be imported in any order</li>
<li>you can use modules and header files together(often happens when upgrading a large system incrementally)</li>
</ul>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>C++ allows you to put functions inside structs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">	int assns, mt, final;</span><br><span class="line">	float grade()&#123; //function inside a struct </span><br><span class="line">		return assns * 0.4 + mt * 0.2 + final * 0.4;</span><br><span class="line">		//the fucntion can get the variables in the struct</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Student s1&#123;60,70,80&#125;;</span><br><span class="line">	Student s1&#123;90,76,65&#125;;</span><br><span class="line">	cout &lt;&lt; s1.grade() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s2.grade() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Terminology:</strong></p>
<ul>
<li>class <ul>
<li>A struct type that contains one or more functions. </li>
<li>The functions give the struct some behaviour</li>
</ul>
</li>
<li>object<ul>
<li>an instance of a class</li>
<li><code>Student</code> is the class, <code>s1</code> is the object <code>&#123;60, 70, 80&#125;</code> is the initialization</li>
</ul>
</li>
<li>The function <code>grade</code> is called a <strong>member function</strong> or <strong>method</strong></li>
<li><code>assns</code> <code>mt</code> and <code>final</code> are called data members, or <strong>member fields(or field)</strong> or <strong>member variables</strong></li>
</ul>
<p>Sometimes the function body is written separately from the class definition:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">	int assns, mid, final;</span><br><span class="line">	float grade();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">float Student::grade()&#123;</span><br><span class="line">	return assns * 0.4 + mid * 0.2 + final * 0.4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>the <code>Student</code> after <code>float</code> qualifies the <strong>function name</strong><br>you can just export <code>struct Student</code>, no need to export <code>grade</code> function, cuz it belongs to the struct </p>
<p>Notes:</p>
<ul>
<li><p><code>::</code> &#x2F;&#x2F; called the <strong>scope resolution</strong> operator. <code>Student :: grade</code> means <code>grade</code> in the context of the class <code>Student</code></p>
</li>
<li><p>The fields <code>assns</code> <code>mt</code> <code>final</code> are fields of the <strong>receiver objects</strong> - the objects upon which the grade method was called</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.grade(); //method call; uses s1&#x27;s data members</span><br></pre></td></tr></table></figure></li>
<li><p>Formally, every method has a hidden extra parameter called <strong>this</strong> , which is a pointer (not a reference) to the <strong>receiver objects</strong></p>
</li>
</ul>
<p><strong>We write:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">float grade()&#123; //function inside a struct </span><br><span class="line">	return assns * 0.4 + mt * 0.2 + final * 0.4;</span><br><span class="line">	//the fucntion can get the variables in the struct</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s1.grade();</span><br></pre></td></tr></table></figure>
<p><strong>The compiler rewrites our code as:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float grade(Student *this)&#123;</span><br><span class="line">	return this-&gt;assns * 0.4 + this-&gt;mt * 0.2 + this-&gt;final * 0.4;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s1.grade();</span><br></pre></td></tr></table></figure>

<p>We can actually refer to <strong>this</strong> inside our function body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">	...</span><br><span class="line">	float grade()&#123;</span><br><span class="line">		return this-&gt;assns ...;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Special-Purpose-Class-Methods-Big-5"><a href="#Special-Purpose-Class-Methods-Big-5" class="headerlink" title="Special-Purpose Class Methods(Big 5):"></a>Special-Purpose Class Methods(Big 5):</h2><p>These are methods you may need to implement in your classes:</p>
<ul>
<li>constructors(<code>ctor</code>)</li>
<li>copy constructors(<code>cctor</code>, <code>copy ctor</code>)</li>
<li>destructors(<code>dtor</code>)</li>
<li>copy assignment operators</li>
<li>move constructors</li>
<li>move assignment operator</li>
</ul>
<h2 id="Constructors-initial-objects"><a href="#Constructors-initial-objects" class="headerlink" title="Constructors(initial objects)"></a>Constructors(initial objects)</h2><p><code>Studnet s1&#123;60, 70, 80&#125;; //OK but limited</code><br><code>Student s2&#123;-100, 1000&#125;; //valid but doesn&#39;t create a valid student</code></p>
<ul>
<li>No validation - negative numbers, numbers larger than 100</li>
<li>don’t have to specify a value for each field</li>
<li>puts the burden on the user of your class to initiate it correctly</li>
</ul>
<p>A better approach is to write a <strong>method</strong> that initialize the object properly.<br>We call such a method a constructor(<code>ctor</code> for short)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">	int assns, mid, final;</span><br><span class="line">	float grade(); //regular method</span><br><span class="line">	Student&#123;int assns, int mid, int final&#125;; //constructor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Student::Student(int assns, int mid, int final) &#123;</span><br><span class="line">	this-&gt;assns = assns;</span><br><span class="line">	this-&gt;mid = mid;</span><br><span class="line">	this-&gt;final = final;</span><br><span class="line">	   |             |</span><br><span class="line">	//field      //parameter</span><br><span class="line"></span><br><span class="line">//Recall this is a pointer to the reciever object Student *this</span><br><span class="line">//if the parameter name different from field name, we don&#x27;t need to use this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//The following are equivalent[stack allocated]</span><br><span class="line">Student s &#123;60, 70, 80&#125;;  //This causes the ctor to run</span><br><span class="line">Student s = &#123;60, 70 ,80&#125;;</span><br><span class="line">Student s = Student &#123;60, 70, 80&#125;;</span><br><span class="line">Student s = Student (60, 70, 80);</span><br><span class="line"></span><br><span class="line">//The following are equivalent[heap allocated]</span><br><span class="line">Student *p = new Student&#123;60, 70, 80&#125;;</span><br><span class="line">Student *p = new Student(60, 70, 80);</span><br></pre></td></tr></table></figure>

<p><strong>A constructor method</strong></p>
<ul>
<li>has the same name as the class</li>
<li>has no return type(not even <code>void</code>)</li>
<li>can be defined with 0 or more parameters</li>
<li>the values in the <code>&#123;...&#125;</code> are passed as arguments to the constructor(<code>ctor</code>)</li>
<li>can have multiple constructors with different parameter list(i.e. real number, complex number)</li>
</ul>
<p><strong>Advantages of constructors</strong></p>
<ul>
<li>they’re functions</li>
<li>you can write initialization code that creates <strong>valid</strong> object that are ready to use</li>
<li>validate parameters</li>
<li>have <strong>default</strong> parameters</li>
<li>overloading –&gt; multiple <code>ctors</code> with different sets of parameters</li>
</ul>
<p><strong>Default Values</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">	...</span><br><span class="line">	Student(int assns = 0, int mid = 0, int final = 0)&#123; //Defaults</span><br><span class="line">		this-&gt;assns;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student s1 &#123;60,70&#125;;  //60,70,0</span><br><span class="line">Student s2 &#123;60&#125;;  //60,0,0</span><br><span class="line">Student s3 &#123;&#125;;  //0,0,0</span><br><span class="line">Student s4;  //same as s3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Every time calls the <code>ctor</code>. Whenever an object is created, a <code>ctor</code> is always called. If you don’t write your own <code>ctor</code>, the class automatically gets a default(i.e. a zero-argument) <code>ctor</code>. The default constructor, in turn, default-construct all of the fields that are objects(using the default <code>ctor</code> for each field)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec v; //default constructor is called</span><br></pre></td></tr></table></figure>

<p>But the built-in default <code>ctor</code> goes away if you write <strong>any</strong> <code>ctor</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student Vec&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	Vec(int x, int y)&#123;</span><br><span class="line">		this-&gt;x = x;</span><br><span class="line">		this-&gt;y = y;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec v; //This is no 0-arg constructor anymore </span><br><span class="line">Vec v&#123;1,2&#125;; //OK</span><br></pre></td></tr></table></figure>

<p>Now consider:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Basis&#123;</span><br><span class="line">	Vec v1, v2;</span><br><span class="line">&#125;;</span><br><span class="line">Basis b; //won&#x27;t compile</span><br><span class="line"></span><br><span class="line">//default ctor for Basis attempts to default-construct the field inside Basis that are objects. But the Vec class doesn&#x27;t have a default ctor.</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; Can we write our own? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Struct Basis &#123; </span><br><span class="line">	Vec v1, v2; </span><br><span class="line">	Basis () &#123; </span><br><span class="line">		v1 = Vec&#123;1,0&#125;; </span><br><span class="line">		v2 = Vec&#123;0,1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; //this does not work</span><br></pre></td></tr></table></figure>

<h2 id="Member-Initialization-Lists-MIL"><a href="#Member-Initialization-Lists-MIL" class="headerlink" title="Member Initialization Lists (MIL)"></a>Member Initialization Lists (MIL)</h2><p><strong>Object Creation Steps</strong><br><strong>When an object is created:</strong> </p>
<ol>
<li>space is allocated </li>
<li>fields are constructed in declaration order(the order in which they appear in class)<ol>
<li>Built-in types(<code>int</code> <code>char</code> <code>bool</code> etc.) are not initialized</li>
<li>Class run for fields <strong>that are objects</strong></li>
</ol>
</li>
<li><code>ctor</code> body runs</li>
</ol>
<p>Initialization of <code>v1</code> and <code>v2</code>  needs to happen in step 2, not step 3. How?</p>
<p> <strong>MIL</strong><br>We have to change our <code>ctor</code> to use a member initialization list</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basis::Basis():v1&#123;1,0&#125;, v2&#123;0,1&#125; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MIL can only appear in a <code>ctor</code></li>
<li>MIL appears between the parameter list and the ctor body</li>
<li>starts with a colon and is a comma-separated list of field initialization</li>
<li>must be in the ctor <strong>implementation</strong>(not prototypes)</li>
<li>can be used to initialize <strong>any</strong> types of fields (not just objects)</li>
<li>fields are initialized in declaration order, even if the MIL orders them differently <ul>
<li>compiler warning</li>
</ul>
</li>
<li>often the MIL does <strong>all</strong> the initialization and the ctor body can be empty</li>
</ul>
<p><strong>Using the default object values and the MIL together:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Basis&#123;</span><br><span class="line">	//if MIL doesn&#x27;t supply a value for the field, these value will be used</span><br><span class="line">	Vec v1&#123;1,0&#125;, v2&#123;0,1&#125;; </span><br><span class="line">	Basis () &#123;&#125; // uses defaults above</span><br><span class="line">	Basis (const Vec &amp;v1, const Vec &amp;v2): v1&#123;v1&#125;, v2&#123;v2&#125;, &#123;&#125;</span><br><span class="line">	//uses the parameters to initialize v1 and v2 if 2 vectors are given</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Using MIL is sometimes more efficient than setting fields in the ctor body</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">	int assns, mid, final; //not objects</span><br><span class="line">	string name; //object</span><br><span class="line">	Student (int a, ..., const string &amp;n) &#123;</span><br><span class="line">		assns = a;</span><br><span class="line">		...</span><br><span class="line">		name = n; </span><br><span class="line">		// gets executed in step 3, must have done step 2</span><br><span class="line">		// in step 2 it default constructed a string to empty </span><br><span class="line">		// in step 3 it reassigned name</span><br><span class="line">		//(name is default constructed to an empty string in step2 and reassigned here)</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	OR</span><br><span class="line">	USE MIL:</span><br><span class="line">	Student (int a, ..., const string &amp;n): assigns&#123;assns&#125;, ... name&#123;n&#125; &#123;&#125; </span><br><span class="line">	// all the work is done in step 2 </span><br><span class="line">	// name is assigned in initialization only once</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MIL must be used:</strong><br>    - for fields that are objects with no default ctors(Vec example with Basis)<br>    - fields that are <strong>const</strong> or <strong>references</strong>(because these cannot be re-assigned; must be initialized in step2)<br>—&gt; MIL should be used as much as possible!</p>
<h1 id="Class-7"><a href="#Class-7" class="headerlink" title="Class 7"></a>Class 7</h1><p><strong>—copy ctor, conversion, dtor</strong></p>
<h2 id="Copy-Constructors"><a href="#Copy-Constructors" class="headerlink" title="Copy Constructors"></a>Copy Constructors</h2><p>Consider:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s&#123;60, 70, 80&#125;;</span><br><span class="line">Student s2 = s;</span><br><span class="line">Student s3 = &#123;s&#125;; //equivalent</span><br></pre></td></tr></table></figure>
<p>How does this initialization happen?</p>
<ul>
<li>the copy constructor </li>
<li>for constructing one object as an copy of another</li>
</ul>
<p><strong>Note: Every class comes with:</strong></p>
<ul>
<li>default ctor<ul>
<li>lost if you write any custom constructor</li>
</ul>
</li>
<li>copy ctor</li>
<li>copy assignment operator</li>
<li>destructor</li>
<li>move ctor</li>
<li>move assignment operator</li>
</ul>
<h3 id="Custome-copy-ctor"><a href="#Custome-copy-ctor" class="headerlink" title="Custome copy ctor"></a>Custome copy ctor</h3><p><strong>Building your own copy ctor:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">	...</span><br><span class="line">	//const Student, doesn&#x27;t have to be const but good to do so</span><br><span class="line">	Student (const Student &amp;other): assns&#123;other.assns&#125;, mid(other.mid), final&#123;other.final&#125; &#123;&#125;</span><br><span class="line">		</span><br><span class="line">&#125;; //equivalent to the defualt ctor we get for free</span><br></pre></td></tr></table></figure>

<h3 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h3><p>When is the built-in copy ctor incorrect?<br>Consider:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">//linked list</span><br><span class="line">Node *n = new Node&#123;1, new Node&#123;2, new Node &#123;3, nullptr&#125;&#125;&#125;;</span><br><span class="line">Node m = *n;</span><br><span class="line">Node *p = new Node&#123;*n&#125;; //p should be a pointer in the stack</span><br><span class="line">//last two are copy ctor</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="/pictures/926.pdf" width="100%" height="550" type="application/pdf">
	</div>





	<div class="row">
    <embed src="/pictures/9262.pdf" width="100%" height="550" type="application/pdf">
	</div>




<p> Simple copy of fields-&gt;only the first node is actually copied(<strong>shallow</strong> copy)<br> If you want a <strong>deep</strong> copy (copied the whole list), must write your own copy ctor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	Node (const Node &amp;other):</span><br><span class="line">		data&#123;other.data&#125;, </span><br><span class="line">		next&#123;other.next? new Node &#123;*other.next&#125;: nullptr&#125; &#123;&#125;</span><br><span class="line">		//calls our copy ctor here at &#x27;new Node&#123;*other.next&#125;&#x27;</span><br><span class="line">		//recursively copies from the rest of the list</span><br><span class="line">		//&#x27;new Node&#x27; allocate memory in heap and return a pointer, type Node*</span><br><span class="line">		//so we need to do *other.next as a Node to be copied</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The copy ctor is called:</p>
<ol>
<li>when an object is initialized by another object of the same type</li>
<li>when an object is passed by value</li>
<li>when an object is returned by value</li>
</ol>
<p>The truth is more nuanced as we’ll se</p>
<p>Q: Why is this wrong?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sturct Node&#123;</span><br><span class="line">	Node (Node other): ....&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">//this is passed by value, before you go to the copy ctor you have to go to the copy stor</span><br></pre></td></tr></table></figure>
<p>A: Taking “other” by value implies that “other” is being copied, which means the copy ctor must be called before we can begin executing the copy ctor(infinity recursion).</p>
<h2 id="Conversion-constructor"><a href="#Conversion-constructor" class="headerlink" title="Conversion constructor"></a>Conversion constructor</h2><p>Note: Careful with ctors that take one arg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node&#123;int data&#125;:...</span><br><span class="line">or</span><br><span class="line">Node(int data, Node *next = nullptr): data&#123;data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">	</span><br><span class="line">The single-argument ctor are called conversion constructors andn they create implicit conversions:</span><br><span class="line">	int x;</span><br><span class="line">	...</span><br><span class="line">	Node n = x; //implicit conversion from int to Node</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">Node n&#123;4&#125;;</span><br><span class="line">-but also  Node n = 4; //equivalent</span><br></pre></td></tr></table></figure>
<p>When have we seen this before?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;Hello&quot;;</span><br><span class="line">	  |           |</span><br><span class="line">string object  const char*(c-style string)</span><br><span class="line">-implicit conversion via single-arg ctor</span><br></pre></td></tr></table></figure>
<p>What’s the problem?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f(Node n),;</span><br><span class="line">f(4); //works, 4 implicitly conversion to Node</span><br></pre></td></tr></table></figure>

<p><strong>Danger:</strong></p>
<ul>
<li>accidentally passing an int to a function expecting Node</li>
<li>silent conversion</li>
<li>compiler does not signal an error</li>
<li>potential errors not caught<br>Don’t do things that limit your compiler’s ability to help you!<br>Disable the implicit conversion - <strong>make the ctor explicit</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	explicit Node(int data, Node *next = nullptr): data&#123;data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n = 4; //now these implicit conversion give compiler errors</span><br><span class="line">f(4); //no</span><br><span class="line"></span><br><span class="line">//But these explicit conversion are okay</span><br><span class="line">Node n&#123;4&#125;;</span><br><span class="line"></span><br><span class="line">f(Node&#123;4&#125;); //OK //this is saying that you want to pass by int</span><br></pre></td></tr></table></figure>
Advice: Always use the explicit keyword on ctors that can be called with a single argument</li>
</ul>
<h2 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h2><p>When an object is destroyed:</p>
<ul>
<li>stack-allocated: goes out of scope</li>
<li>heap-allocated: is deleted</li>
</ul>
<p>A method called the <strong>destructor</strong> runs</p>
<p>Classes come with a default dtor (just calls dtor for all the fields that are objects)<br><strong>Object destruction steps:</strong><br><strong>When an object is destroyed, 3 steps happen</strong><br><strong>-in reverse declaration order(for fields that are objects)</strong> </p>
<ol>
<li>Dtor body runs</li>
<li>fields that are objects - their dtors run in reverse declaration order</li>
<li>space is deallocated</li>
</ol>
<p><strong>When do we need to write a dtor?</strong><br><code>Node *np = new Node &#123;1, new Node&#123;2, new Node &#123;3, nullptr&#125;&#125;&#125;;</code><br>If <code>np</code> goes out of scope:</p>
<ul>
<li>the ptr is reclaimed(stack-allocated)</li>
<li>the nodes are leaked<br>If we say delete <code>*np</code></li>
<li>calls <code>*np</code>‘s dtor, which doesn’t do anything</li>
<li>The default destructor destroys the member variables. If the member variables have user defined destructors, they are called. If they are fundamental types, nothing happens.</li>
</ul>
<p>Write a dtor to ensure the whole list is freed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">	...</span><br><span class="line">	 ~Node()&#123;delete next;&#125; </span><br><span class="line">	//recursively calls *next&#x27;s dtor; whole list is freed</span><br><span class="line">&#125;;</span><br><span class="line">delete np; //frees the whole list </span><br></pre></td></tr></table></figure>
<p>What happens when you reach the <code>nullptr</code> at the end of the list</p>
<ul>
<li>Deleting a <code>nullptr</code> is guaranteed to be safe(and do nothing). The recursion stops.</li>
</ul>
<p>To declare a dtor:</p>
<ul>
<li>start with a ~</li>
<li>same name as class</li>
<li>no return type</li>
<li>no parameters</li>
<li>can have only one dtor in class</li>
</ul>
<p>if you write the dtor outside the struct:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node::~Node()&#123; //make sure `Node::` is in the right spot</span><br><span class="line">	delete next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dtors have an important role in C++ programs: they are guaranteed to run when an object is destroyed. Dtor often clean up or release resources their objects are holding onto.</p>
<p>Caution:</p>
<ul>
<li>if you use the <code>exit()</code> function, dtors will not run</li>
<li>Valgrind will report memory leak</li>
</ul>
<h1 id="Class-8"><a href="#Class-8" class="headerlink" title="Class 8"></a>Class 8</h1><p><strong>—copy assignment operator, Rvalue, move assignment operator</strong></p>
<h2 id="Copy-Assignment-Operator"><a href="#Copy-Assignment-Operator" class="headerlink" title="Copy Assignment Operator"></a>Copy Assignment Operator</h2><p>The goal of the copy assignment operator is to <strong>replace</strong> the data in an object with a <strong>copy</strong> of the data from another object of the same type , without introducing memory leaks.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student s1&#123;6,7,8&#125;;</span><br><span class="line">Student s2 = s1;//copy ctor</span><br><span class="line">Student s3; //default ctor</span><br><span class="line">...</span><br><span class="line">s3 = s1; //copy, but not construction</span><br><span class="line">//`=` is copy assignment operator - uses ompiler-supplied default</span><br><span class="line">//calls the copy assignment operator, s1&#x27;s data is copied into s2(s2&#x27;s old data is overwritten). s1 should be unchanged</span><br></pre></td></tr></table></figure>
<p>The compiler provides a default copy assignment operator for every class.</p>
<p><strong>Note: assignment NOT equal to construction</strong><br><strong>(cuz we have “old stuff” that we gotta deal with first)</strong><br><strong>may need to write your own</strong></p>
<p><strong>Node</strong><br><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	Node &amp;operator=(const Node &amp;other)&#123;</span><br><span class="line">		data = other.data;</span><br><span class="line">		delete next;</span><br><span class="line">		next = other.next? new Node&#123;*other.next&#125;:nullptr;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125; //DANGEROUS!!</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above is DANGEROUS!!<br>Why?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node n &#123;1, new Node&#123;2, new Node &#123;3, nullptr&#125;&#125;&#125;;</span><br><span class="line">n = n;</span><br><span class="line">//delete n and tries to copy n to n</span><br><span class="line">//undefined behaviour </span><br></pre></td></tr></table></figure>
<p>When writing operator <code>=</code> , always make sure it works well in the case of self-assignment.<br><strong>Revised:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	Node &amp;operator=(const Node &amp;other)&#123;</span><br><span class="line">		if (this == &amp;other) return *this;</span><br><span class="line">		data = other.data;</span><br><span class="line">		delete next;</span><br><span class="line">		next = other.next? new Node&#123;*other.next&#125;:nullptr;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Student</strong><br>For Student it would look like this: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">	...</span><br><span class="line">	Student &amp;operator = (const Student &amp;other)&#123;</span><br><span class="line">		if (this == &amp;other) return *this; </span><br><span class="line">		//protecting against self-assignment(i.e: s1 = s1)</span><br><span class="line">		//`this` is a pointer to the recieving object</span><br><span class="line">		//this == &amp;other,  `this` and `other` points to the same object</span><br><span class="line">		</span><br><span class="line">		//copy member fields</span><br><span class="line">		assns = other.assns;</span><br><span class="line">		mid = other.mid;</span><br><span class="line">		final = other.final;</span><br><span class="line"></span><br><span class="line">		return *this; //return a reference to ourself </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Q&amp;A</strong><br>Q: How big of a deal is self-assignment? How likely am I to write <code>n = n</code>?<br>A: Not that likely. But consider <code>*p = *q</code> if <code>p</code> $\neq$ <code>q</code> point to the same location. Or <code>a[i] = a[j]</code>if <code>i</code>, <code>j</code> happen to be equal(say in a loop). Because of aliasing, it is a big deal.</p>
<p>Q: What’s wrong with <code>if(*this == other)</code> as a check for self-assignment?<br>A: Exercise</p>
<p>Critiques of the revised version?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	Node &amp;operator=(const Node &amp;other)&#123;</span><br><span class="line">		if (this == &amp;other) return *this;</span><br><span class="line">		data = other.data;</span><br><span class="line">		delete next;</span><br><span class="line">		next = other.next? new Node&#123;*other.next&#125;:nullptr;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//if malloc fail, it returns a null pointer</span><br><span class="line">//but if new Node fail, the copy assignment operator would fail</span><br><span class="line">//but the delete next has been executed</span><br></pre></td></tr></table></figure>

<p><strong>An even better implementation:</strong><br>(want to do the copy before we do the delete)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node &amp;operator=(const Node &amp;other)&#123;</span><br><span class="line">		if (this == &amp;other) return *this;</span><br><span class="line">		Node *tmp = next;</span><br><span class="line">		next = other.next? new Node&#123;*other.next&#125;:nullptr;</span><br><span class="line">		data = other.data;</span><br><span class="line">		delete temp;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125; //if new fails, we still have the old list</span><br></pre></td></tr></table></figure>

<p><strong>Alternative: copy-and-swap idiom</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &lt;utility&gt;;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	void swap(Node &amp;other)&#123;</span><br><span class="line">		std::swap(data, other.data);</span><br><span class="line">		std::swap(next, other.next);</span><br><span class="line">	&#125;</span><br><span class="line">	Node&amp; operator=(const node &amp;other)&#123;</span><br><span class="line">		Node temp = other; //copy ctor</span><br><span class="line">		swap(temp);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;//dtor and ctor need to be defined for this method</span><br></pre></td></tr></table></figure>

<h2 id="Rvalues-Rvalues-References"><a href="#Rvalues-Rvalues-References" class="headerlink" title="Rvalues &amp; Rvalues References"></a>Rvalues &amp; Rvalues References</h2><p>Recall:</p>
<ul>
<li>an <strong>lvalue</strong> is anything with a address</li>
<li>an <strong>lvalue reference</strong>  (<code>&amp;</code>)  is like a const ptr with auto-dereference - always initialized to an lvalue</li>
</ul>
<p>Now consider:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node OddsOrEvens()&#123;</span><br><span class="line">	Node odds &#123;1, new Node&#123;3, new Node &#123;5, nullptr&#125;&#125;&#125;;</span><br><span class="line">	Node evens &#123;2, new Node&#123;4, new Node &#123;6, nullptr&#125;&#125;&#125;;</span><br><span class="line">	char c;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	if (c == `0`) return evens;</span><br><span class="line">	else return odds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node n = OddsOrEvens(); //this is a copy ctor</span><br><span class="line">//copy ctor takes an `&amp;other`</span><br><span class="line">//what is the `other` here? reference to what?</span><br></pre></td></tr></table></figure>
<ul>
<li>compiler takes a temporary object to hold the result of <code>OddsOrEvens()</code></li>
<li><code>other</code> is a reference to this temporary <ul>
<li>copy ctor deep copies the data from this temporary</li>
</ul>
</li>
</ul>
<p>BUT, the temporary is just gonna be discarded anyway, as soon as the statement <code>Node n = OddsOrEvens();</code> is done. </p>
<ul>
<li>wasteful to have to copy the data from the temporary</li>
<li>why not just steal it instead? and save the cost of a copy(“steal dying object stuff”)</li>
</ul>
<p>What could possibly go wrong? - if the object is not “dying”:</p>
<ul>
<li><code>Node n = OddsOrEvens();</code> vs  <code>Node n = m;</code></li>
<li>need to be able to tell whether other is a temporary object(which stealing would work), or a standard object(which we would have to copy)</li>
</ul>
<h3 id="C-11-introduced-rvalue-reference"><a href="#C-11-introduced-rvalue-reference" class="headerlink" title="C++ -11 introduced rvalue reference"></a>C++ -11 introduced rvalue reference</h3><p><strong>rvalue reference</strong> : <code>Node &amp;&amp;</code> is a reference to a temporary object(rvalue) of type Node</p>
<p>Version of the ctor that takes a <code>Node&amp;&amp;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">	...</span><br><span class="line">	Node(Node &amp;&amp;other): //called a move ctor //steal other&#x27;s data</span><br><span class="line">		data&#123;other.data&#125;; //integer assignment </span><br><span class="line">		next&#123;other.next&#125;; //pointer assignment </span><br><span class="line">	&#123;</span><br><span class="line">	other.next = nullptr;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Similarly,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node m;</span><br><span class="line">m = OddsOrEvens(); //assignment from temporary </span><br></pre></td></tr></table></figure>

<h2 id="Move-Assignment-Operator"><a href="#Move-Assignment-Operator" class="headerlink" title="Move Assignment Operator:"></a>Move Assignment Operator:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	...</span><br><span class="line">	Node &amp;operator=(Node&amp;&amp; other)&#123;</span><br><span class="line">	//steal other&#x27;s data</span><br><span class="line">	//destroy my old data</span><br><span class="line">	//Easy swap without copy</span><br><span class="line">		std::swap(data, other.data);</span><br><span class="line">		std::swap(next, other.next);</span><br><span class="line">		return *this;</span><br><span class="line">	//temporary will be destroyed and take our old data with it</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If you don’t write a move ctor&#x2F;assignment, the copying version of these operations will be used instead</p>
<h2 id="Summary-Rule-of-5-Big-5"><a href="#Summary-Rule-of-5-Big-5" class="headerlink" title="Summary: Rule of 5(Big 5)"></a>Summary: Rule of 5(Big 5)</h2><p>If you need to write any one of the Big 5(destructor, copy constructor, copy assignment operator, move constructor, move assignment operator), then you usually need to write all 5.</p>
<p>recall three important indicative understanding of CS246</p>
<ol>
<li>reference</li>
<li>stack&#x2F;heap</li>
<li>ownership</li>
</ol>
<p>But note that many classes don’t need any of these</p>
<ul>
<li>the default implementation are fine<br>What characterizes classes that need the big 5, typically?</li>
<li>ownership <ul>
<li>these classes are usually tasked with managing something</li>
<li>often memory, but there are other things that need managing(resources)</li>
</ul>
</li>
</ul>
<h1 id="Class-9"><a href="#Class-9" class="headerlink" title="Class 9"></a>Class 9</h1><p><strong>—copy&#x2F;move elision, member&#x2F;IO OPERATOR, array of&#x2F;const&#x2F;compare OBJECTS</strong></p>
<h2 id="Copy-Move-Elision"><a href="#Copy-Move-Elision" class="headerlink" title="Copy&#x2F;Move Elision"></a>Copy&#x2F;Move Elision</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vec MakeAVec()&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	Vec v&#123;x,y&#125;;</span><br><span class="line">	return Vec v&#123;x,y&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec v1 = makeAVec(); //What runs? copy ctor? move ctor?</span><br><span class="line">//try it </span><br></pre></td></tr></table></figure>
<p>Under the covers, the compiler makes v and  alias(or a reference) to v1 so that they point to the same object. when v is constructed, it is directly constructed into th ememory where v1 lives. And when <code>MakeAVec</code> returns, no copying or moving is needed.</p>
<p>Answer:</p>
<ul>
<li>just the basic ctor</li>
<li>no copy ctor, no move ctor</li>
<li>in certain cases, the compiler is required to skip calling copy ctor, move ctor

	<div class="row">
    <embed src="/pictures/10_8.pdf" width="100%" height="550" type="application/pdf">
	</div>



In this example, <code>MakeAVec</code> writes its result <code>(&#123;0,0&#125;)</code> directly into the space occupied by <code>v</code> in the caller in <code>main</code> itself, instead of making a <code>vec</code> in <code>MakeAVec()</code> and moving it to <code>main</code>. This is called Copy&#x2F;Move Elision</li>
</ul>
<p>Another example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.g:</span><br><span class="line"></span><br><span class="line">void doSomething(Vec v); // pass-by-value, copy or move ctor</span><br><span class="line"></span><br><span class="line">doSomething(MakeAVec()); //result of MakeAVec written directly into the parameter v</span><br><span class="line">//there is no copy or move involved </span><br></pre></td></tr></table></figure>

<p>This behaviour is called copy&#x2F;move elision, it’s an optimization technique that the compiler uses to eliminate unnecessary copying of object. This happens, even if eliminating the copy&#x2F;move ctors changes the behaviour of the program(rg. if ctors print something)<br>You are not expected to know when exactly elision happens, just that it does happen</p>
<h2 id="Member-Operators"><a href="#Member-Operators" class="headerlink" title="Member Operators"></a>Member Operators</h2><p>When an operator function is declared as a member function, then <code>this</code> object plays the role of the <strong>first operand(x * k not k * x).</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Vec&#123;</span><br><span class="line">	...</span><br><span class="line">	//v1+v2 ----[return new Vec objects]</span><br><span class="line">	Vec operator+(const Vec&amp;rhs) const&#123;</span><br><span class="line">		//Note the const designates that the method </span><br><span class="line">		//does not change the reciever object(leave the member data alone).</span><br><span class="line">		</span><br><span class="line">		return&#123;x+rhs.x, y+rhs.y&#125;;//return by value</span><br><span class="line">		</span><br><span class="line">		//memebr functions automatically have access to member fields</span><br><span class="line">	&#125;</span><br><span class="line">	//v * k ----[return new Vec objects]</span><br><span class="line">	Vec operator *(const int k) const&#123;</span><br><span class="line">		return &#123;x * k, y * k&#125;; //return by value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//v1 += v2 ----[return updated Vec objects]</span><br><span class="line">	Vec &amp;operator += (const Vec &amp;rhs)&#123; //Note: not const</span><br><span class="line">		x += rhs.x;</span><br><span class="line">		y += rhs.y;</span><br><span class="line">		return *this; //return by reference(main stack allocated,updated Vec obj)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note we did not implement <code>k*v</code> above, why? can’t be a member function because the first operand is not a <code>Vec</code> , so must be a standalone function.</p>
<p><strong>Notes:</strong><br><code>operator =</code> is a <strong>member function of the class(method)</strong><br>previous operators like <code>operator+()</code>we have written have been <strong>standalone functions</strong></p>
<p>When an operator is declared as a <strong>member function</strong>, <code>*this</code> plays the role of the <strong>first</strong>(left) operand</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e.g. of member function declaration</span><br><span class="line"></span><br><span class="line">struct Vec&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	...</span><br><span class="line">	Vec operator+(const Vec &amp;other)&#123;</span><br><span class="line">		return&#123;x + other.x, y + other.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	Vec operator*(int k)&#123;</span><br><span class="line">		return&#123;x * k, y * k&#125;;  //this only works for v * k, not k * v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>How do we implement <code>k * v</code> ? Can’t be a member function, cuz first argument is not <code>Vec</code>, must b external:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec &amp;operator*(const int k, const Vec &amp;v)&#123;</span><br><span class="line">	return v*k; //use the previous implemented member function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Advice: If you overload arithmetic operators, overload the assignment versions of these as well, and implement the former in terms of the latter.</p>
<h2 id="I-O-operators"><a href="#I-O-operators" class="headerlink" title="I&#x2F;O operators:"></a>I&#x2F;O operators:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Vec &#123;</span><br><span class="line">	...</span><br><span class="line">	ostream &amp;operator &lt;&lt; (ostream &amp;out)&#123;</span><br><span class="line">		return out &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>What’s wrong with this?</p>
<ul>
<li>NEED to make <code>Vec</code> the FIRST operand, not the second</li>
<li>SO Use as <code>v &lt;&lt; cout</code>, but this is <strong>Confusing</strong></li>
<li><code>w &lt;&lt; (v &lt;&lt; cout))</code></li>
</ul>
<p>So defined <code>&lt;&lt;</code>, <code>&gt;&gt;</code> as standalone<br>Certain operators must be members:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">operator=</span><br><span class="line">operator[]</span><br><span class="line">operator-&gt;</span><br><span class="line">operator()</span><br><span class="line">operator T (where T is a type)</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-of-Objects"><a href="#Arrays-of-Objects" class="headerlink" title="Arrays of Objects"></a>Arrays of Objects</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Vec&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	Vec(int x, int y): x&#123;x&#125; y&#123;y&#125; &#123;&#125; //custome ctor, removes the defualt ctor </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec *vp = new Vec[10]; //heap allocated</span><br><span class="line">Vec moveVecs[10];  //stack allocated </span><br><span class="line">//WRONG!!</span><br></pre></td></tr></table></figure>
<p>These want to call the default constructor on each item(objects need to be initialized). If no  default ctor(customized already)- can’t initialize the array items—error(objects in C++ need to be initialized)</p>
<p><strong>Options:</strong></p>
<ol>
<li>provide a default ctor<ol>
<li>this is not a good idea unless it makes sense for the class to have a default ctor</li>
</ol>
</li>
<li>For stack arrays(provide an initialization list to init each object)<ol>
<li><code>Vec moveVecs[3] = &#123;&#123;0,0&#125;, &#123;1,1&#125;, &#123;2,2&#125;&#125;;</code></li>
</ol>
</li>
<li>For heap arrays - array of pointers<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec **vp = new Vec* [5];</span><br><span class="line">vp[0] = new Vec&#123;...&#125;;</span><br><span class="line">vp[1] = new Vec&#123;...&#125;;</span><br><span class="line">...</span><br><span class="line">for (int i = 0; i &lt; 5; ++i) delete vp[i];</span><br><span class="line">delete[] vp;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vec **vp = new Vec[capacity]&#123;nullptr&#125;;</span><br><span class="line">//intialize the first object to nullptr and</span><br><span class="line">//automatically initializes the rest of the array objects to 0</span><br><span class="line">//and 0 is equivalent to nullptr</span><br><span class="line">//nullptr is ONLY used to initialized the FIRST object</span><br></pre></td></tr></table></figure>
<h2 id="Const-Objects"><a href="#Const-Objects" class="headerlink" title="Const Objects"></a>Const Objects</h2><p><code>int f(const Node &amp;n) &#123;...&#125;</code></p>
<ul>
<li>const objects arise often, especially as function parameters<br>What is a <strong>const object</strong>?</li>
<li>an object where the fields cannot be mutated<br>Can we call methods on const objects?</li>
<li>issue: the method may change fields, violate const</li>
<li>answer: YES, we can call methods that promise not to modify fields<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">struct Student&#123;</span><br><span class="line">	int assns, mid, final;</span><br><span class="line">	float grade() const; </span><br><span class="line">	//this doesn&#x27;t modify fields of objects called,</span><br><span class="line">	//so declare it const, this is a [const method]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">floas Student::grade()const &#123;</span><br><span class="line">	//the `const`suffix must appear </span><br><span class="line">	//in both interface and implementation files</span><br><span class="line">	return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>the <code>const</code>suffix must appear in both interface and implementation files</li>
<li>compiler checks that const methods don’t modify fields</li>
<li>only const methods can be called on const objects</li>
</ul>
<p>You get a compiler error if:</p>
<ul>
<li>you write a const method on a non-const object</li>
<li>the code inside a const method tries to modify any fields</li>
</ul>
<p>Advice: Any method that doesn’t update the object’s fields should be a const method(add the const key word) Then you can invoke those methods on const objects</p>
<p>One can mark certain fields as mutable:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">	mutable int numMethodCalls = 0;</span><br><span class="line">	fload grade()const&#123;</span><br><span class="line">		++numMethodCalls;</span><br><span class="line">		return ...;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mutable fields can be updated even if from a const method<br>But updating numMethodCalls affect only the <strong>physical constness</strong> of the object, not the <strong>logical constness</strong></p>
<ul>
<li>physical constness: whether the actual bits that make up the object have changed.</li>
<li>logical constness: whether the externally visible state of the object has changed.</li>
<li>use mutable to indicate that a field does not contribute to the logical constness of the object.</li>
</ul>
<h2 id="Comparing-Objects"><a href="#Comparing-Objects" class="headerlink" title="Comparing Objects"></a>Comparing Objects</h2><p>Comparing strings in C:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int result = strcmp(s1, s2); //char *s1, *s2</span><br><span class="line">result = 0 if s1 == s2</span><br><span class="line">	   &gt; 0 if s1 &lt; s2</span><br><span class="line">	   &lt; 0 if s2 &lt; s1</span><br></pre></td></tr></table></figure>
<p>String comparison in C++:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 == s2</span><br><span class="line">s1 &lt; s2</span><br><span class="line">s1 &gt; s2</span><br><span class="line">s1 != s2</span><br></pre></td></tr></table></figure>

<p>C++ version is easier to read, but you might need to do multiple comparisons</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (s1 == s2)&#123;  //compare </span><br><span class="line">	...</span><br><span class="line">&#125;else if (s1 &lt; s2)&#123; //compare </span><br><span class="line">	...</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ has a three-way comparison operator : <code>&lt;=&gt;</code>(a.k.a the spaceship operator)<br><code>s1 &lt;=&gt; s2</code> &#x2F;&#x2F;returns a special value indicating less than, equal to, or greater than</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &lt;compare&gt;; //must import this</span><br><span class="line"></span><br><span class="line">std::str0ng_ordering result = s1 &lt;=&gt; s2;</span><br><span class="line">	</span><br><span class="line">//note the return type std::strong_ordeirng</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results:</span><br><span class="line">std::strong_ordering::equal</span><br><span class="line">std::strong_ordering::less</span><br><span class="line">std::strong_ordering::greater</span><br><span class="line">std::strong_ordering::equivalent (same as equal)</span><br></pre></td></tr></table></figure>
<p>can also compare against <code>0</code> but only <code>0</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(result == 0)&#123; //s1 == s2</span><br><span class="line">	...</span><br><span class="line">&#125;else if (result &lt; 0)&#123; //s1 &lt; s2</span><br><span class="line">	...</span><br><span class="line">&#125;else&#123; //s1 &gt; s2</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Class-10"><a href="#Class-10" class="headerlink" title="Class 10"></a>Class 10</h1><p><strong>—compare objects, encapsulation, design pattern(iterator)</strong></p>
<p><strong>Side Note</strong><br>C++ allows you to declare variables and function return types with the <strong>auto</strong> keyword:<br><code>auto result = s1 &lt;=&gt; s2;</code><br>&#x2F;&#x2F;called automatic type declaration<br>In general:<br><code>auto x = expr;</code> &#x2F;&#x2F;declares <code>x</code> to have the type matching the value of expression</p>
<h2 id="Comparing-Objects-continued"><a href="#Comparing-Objects-continued" class="headerlink" title="Comparing Objects(continued)"></a>Comparing Objects(continued)</h2><p>One can add support for <code>&lt;=&gt;</code> to our own classes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">student Vec&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	auto operator&lt;=&gt;(const Vec&amp; other)const&#123;</span><br><span class="line">		auto n = x &lt;=&gt; other.x;</span><br><span class="line">		if (n != 0) return n;</span><br><span class="line">		return y &lt;=&gt; other.y; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>so now we can say:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec v1, v2;</span><br><span class="line">...</span><br><span class="line">auto result = v1 &lt;=&gt; v2;</span><br></pre></td></tr></table></figure>
<p>By writing operator <code>&lt;=&gt;</code> we get the 6 relational operators, <code>==</code>, <code>!=</code>, <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> for free:<br><code>v1 &lt;= v2  &lt;=&gt;  (v1&lt;=&gt;v2) &lt;= 0</code></p>
<p>We can sometimes also get operator<code>&lt;=&gt;</code> for free, well almost!<br><code>auto operator &lt;=&gt; (const Vec &amp;other) const = default;</code></p>
<p>This automatically generates a default implementation which just compares the fields one-by-one using <code>&lt;=&gt;</code>, same as what we wrote above.</p>
<p>FOR <code>Node</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto operator &lt;=&gt; (const Node &amp;other)const&#123;</span><br><span class="line">	auto n = data &lt;=&gt; other.data;</span><br><span class="line">	if (n != 0) return n;</span><br><span class="line">	if (next == nullptr &amp;&amp; other.next == nullptr) return n;</span><br><span class="line">	if (next == nullptr) return std::strong::ordering less;</span><br><span class="line">	if (other.next == nullptr) return std::strong::ordering greater;</span><br><span class="line">	return *next &lt;=&gt; *other.next; //Recursively check next pair </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Invariants-and-Encapsulation"><a href="#Invariants-and-Encapsulation" class="headerlink" title="Invariants and Encapsulation"></a>Invariants and Encapsulation</h2><p>Consider:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node *next;</span><br><span class="line">	...</span><br><span class="line">	~Node()&#123;delete next;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n3&#123;3, nullptr&#125;;</span><br><span class="line">Node n2&#123;2, &amp;n3&#125;;</span><br><span class="line">Node n1&#123;1, &amp;n2&#125;;</span><br></pre></td></tr></table></figure>
<p>What happens when these variables go out of scope?<br><code>n2</code>‘s dtor will try to delete <code>n3</code> , which is an the stack undefined behaviour(UB)<br>e.g.: stack invariant: </p>
<ul>
<li>last item pushed is the first item popped</li>
<li>but not if the client can rearrange the underlying data</li>
</ul>
<p>Class Node relies on an assumption for its proper behaviour that next is either <code>nullptr</code> or points to a <code>Node</code> on the <strong>heap</strong>.</p>
<p>This assumption is an example of an <strong>invariant</strong> - a statement that must be true - upon which <code>Node</code>relies.</p>
<p>But by expressing the next field, we allow clients to manipulate it directly, so we can’t guranteed the invariant.</p>
<p>It’s hard to reason about programs if you can’t rely on invariants.<br>To enforce invariants, we introduce <strong>encapsulation</strong> , so needed because we want clients to treat our objects as black boxes(or capsules).</p>
<p>That creates <strong>abstractions</strong>, in which implementation details are hidden. When we design our classes, we choose which details we want to expose to clients and hide the internal implementation details.</p>
<ul>
<li>seal away implementations</li>
<li>only interact via provided methods</li>
<li>regains control over our objects</li>
</ul>
<p>How do we hide implementation details? we made certain members(fields and methods) private?:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Vec&#123;</span><br><span class="line">	private:</span><br><span class="line">		int x, y; //can&#x27;t be accessed outside of struct Vec</span><br><span class="line">	public:</span><br><span class="line">		Vec(int x, int y); //default visibility is public</span><br><span class="line">		Vec operator+(...)...</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ also lets us define a struct using the class keyword:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Vec&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">	public:</span><br><span class="line">		Vec (int x, int y);</span><br><span class="line">		Vec operator+(const Vec&amp;other);</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Both classes and structs can be used to define classes. The <strong>only</strong> difference:</p>
<ul>
<li>in a struct, members are public by default</li>
<li>in a class, members are private by default</li>
</ul>
<p>In general, we want our class members(in particular data members) to be private, we want default visibility to be private –&gt; <strong>switch from struct to class</strong></p>
<p>Let’s fix our linked list example by using encapsulation. The key is to create a wrapper class List that uses Node internally. The Node class won’t be exposed to users of our class.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//list.cc(interface)</span><br><span class="line">export class List&#123;</span><br><span class="line">	//only accessible within List</span><br><span class="line">	struct Node; //Forward deel of Node struct. Node is a private nested class.</span><br><span class="line">	Node *theList = nullptr; //head of list</span><br><span class="line">	int list_size = 0; //size of list</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void addToFront(int n); //&quot;cons&quot;</span><br><span class="line">	int size()const;</span><br><span class="line">	int &amp;operator[](int i)const; //int &amp;ith (int i)</span><br><span class="line">	~List();</span><br><span class="line">	...also need big 5...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>private nested class, we can do class BinaryTree-&gt;class struct Node too</li>
<li><code>int &amp;ith(int i)</code>: <ul>
<li>returning an int refe, cuz you may want to mutate the element of the list</li>
<li>this is not a copy of the element, it is THE element</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//list-impl.cc</span><br><span class="line">struct List::Node &#123; //same node we used before.</span><br><span class="line">	int data;</span><br><span class="line">	Node *next;</span><br><span class="line">	...big 5</span><br><span class="line">	~Node&#123;delete next;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void List::addToFront(int n)&#123;</span><br><span class="line">	theList = new Node&#123;n, theList&#125;;</span><br><span class="line">	list_size ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int List::size() const &#123;return list_size;&#125;</span><br><span class="line">int &amp;operator[](int i) const&#123;</span><br><span class="line">	Node *cur = theList;</span><br><span class="line">	while(i &gt; 0)&#123;cur = cur-&gt;next; i--;&#125;</span><br><span class="line">	return cur-&gt;data; //count i step of the list &amp; return the data field</span><br><span class="line">&#125;</span><br><span class="line">List::~List()&#123;delete next;&#125; //recursion, take stack space cuz recursion happens only if reach the last case(nullptr), iterative can do it by order</span><br></pre></td></tr></table></figure>

<p>Client code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List list;</span><br><span class="line">int i;</span><br><span class="line">while(cin &gt;&gt; i) list.addToFront(i); //we are the only one adding them</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) cout &lt;&lt; list[i] &lt;&lt; &#x27;-&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>This node actually has a time complexity of <code>O(n^2)</code> where <code>n</code> is size of list.</li>
<li>only List can create&#x2F;manipulate Node objects</li>
<li>can guarantee the invariant is always either nullptr or allocated by new</li>
</ul>
<p>NOTES:</p>
<ul>
<li><p><code>&lt;=&gt;</code> comparing objects, if node nullptr, can’t work, but now that we have list as a class, and node nested class, node nullptr  is  now a object</p>
</li>
<li><p>we can place big 5(<code>~List()</code>) in list.cc instead of list-impl.cc(become iterative not recursive, saving stack space)</p>
</li>
<li><p>HOW CAN WE TRAVERSE THE LIST FROM NODE TO NODE AS WE WANT A LINKED LIST?</p>
</li>
<li><p>Repeatedly calling <code>ith</code> to access the whole list &#x3D; O(n^2) time</p>
</li>
<li><p>BUT we can’t expose the node or we lose encapsulation</p>
</li>
</ul>
<h2 id="Introduction-to-Design-Pattern"><a href="#Introduction-to-Design-Pattern" class="headerlink" title="Introduction to Design Pattern"></a>Introduction to Design Pattern</h2><p>Certain programming challenges arise often. As developers, we should keep track of good solutions to these problems and reuse and <strong>adapt</strong> them.(《the book Deign Pattern》)</p>
<p>Essence of <strong>Design Pattern</strong> - if you have this situation, then this programming technique may solve it.</p>
<h2 id="Iterator-Pattern"><a href="#Iterator-Pattern" class="headerlink" title="Iterator Pattern:"></a>Iterator Pattern:</h2><p>We don’t want to give client access to node, we don’t wanna give the client the pointer directly, but we can give them a class that contains the pointer. </p>
<ul>
<li>create a class that manages access to nodes</li>
<li>abstraction of a ptr</li>
<li>walk the list without exposing the actual list</li>
</ul>
<p>C++ has a standard of how iteration generally work. The basic idea behind the iterator pattern, is that we will create a new class called <strong>iterator</strong> that give us access to the nodes;</p>
<ul>
<li>is an abstraction of a pointer</li>
<li>let us walk the list without expressing the actual pointers</li>
</ul>
<p><strong>RECALL CS136</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int *p = arr; p != arrsize; ++p)</span><br><span class="line">	printf(&quot;%d&quot;, *p);</span><br></pre></td></tr></table></figure>
<p>Not use index to iterate, but pointer<br>iterator class we implement <code>*, ++, !=</code></p>
<p><strong>Using Iterator</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	List list;</span><br><span class="line">	...populate the list...</span><br><span class="line">	Node *theList</span><br><span class="line">	//print the list</span><br><span class="line">	List::iterator it = list.begin(); </span><br><span class="line">	//create an iterator object pass the frist item</span><br><span class="line"></span><br><span class="line">	while(it != list.end())&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; `-`;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Implementing Iterator:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class List &#123;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">	class iterator&#123; //nested class</span><br><span class="line">		node *p; //fields to &#x27;convert&#x27; node</span><br><span class="line">		public:</span><br><span class="line">			iterator(Node *p): p&#123;p&#125;&#123;&#125; //ctor</span><br><span class="line">			int &amp;operator*()const &#123;</span><br><span class="line">				return p-&gt;data;</span><br><span class="line">			&#125;</span><br><span class="line">			iterator &amp;operator++()&#123;</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">				return *this;</span><br><span class="line">			&#125;</span><br><span class="line">			bool operator != (const iterator &amp;other)const&#123;</span><br><span class="line">				return p != other.p; </span><br><span class="line">				//not equal if the iterator points to different things</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	//method of the list</span><br><span class="line">	iterator begin()const&#123;return iterator&#123;theList&#125;;&#125;</span><br><span class="line">	iterator end()const&#123;return iterator&#123;nullptr&#125;;&#125; </span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>class iterator doesn’t have access to List <code>theList</code></li>
<li>the only field class iterator has is a pointer, i want the iterator to point at <code>theList</code></li>
<li>end() means one pass the end (<code>arrsize</code> that <code>p</code> compares with)<ul>
<li>if it is a linked list, it is a nullptr</li>
<li>if it is an array, it is an address</li>
</ul>
</li>
</ul>
<p>Client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List l;</span><br><span class="line">l.addToFront(1);</span><br><span class="line">l.addToFront(2);</span><br><span class="line">l.addToFront(3);</span><br><span class="line">...</span><br><span class="line">for (List::iterator it = l.begin(); it != l.end(); ++it)&#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Shortcut:</strong><br><strong>range-based for loop:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto n:l)&#123;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Available for any class with </p>
<ul>
<li>methods begin and end that produce iterators</li>
<li>the iterators must support <code>!=</code>, prefix<code>++</code>, <code>unary *</code></li>
<li>(postfix require a little more work)</li>
</ul>
<p>If you want to mutate list items(or save copying)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto &amp;n : l)&#123;</span><br><span class="line">	++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Will revisit iterators later</p>
<h2 id="Encapsulation-Continued"><a href="#Encapsulation-Continued" class="headerlink" title="Encapsulation Continued"></a>Encapsulation Continued</h2><p>List clients can create iterators directly:<br>&#96;auto it &#x3D; List::iterator(){nullptr};’<br>this violates encapsulation, the client should be using begin() and end()<br>(cuz what if we don’t want the end to be nullptr anymore)</p>
<p>We could make the iterator ctor private</p>
<ul>
<li>then the client can’t call <code>List::iterator&#123;--&#125;</code></li>
<li>but then neither can List class</li>
</ul>
<p>Sol:</p>
<ul>
<li>give List privileged access to iterator</li>
<li>make it a <strong>friend</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class List&#123;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">		class iterator&#123;</span><br><span class="line">			Node *p;</span><br><span class="line">			iterator(Node *p);</span><br><span class="line">			public:</span><br><span class="line">			...</span><br><span class="line">			//List has access to all members of iterator</span><br><span class="line">			friend class List;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Class-11"><a href="#Class-11" class="headerlink" title="Class 11"></a>Class 11</h1><h2 id="Encapsulation-continued"><a href="#Encapsulation-continued" class="headerlink" title="Encapsulation continued"></a>Encapsulation continued</h2><p>Recall:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class List&#123;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">		class Iterator &#123;</span><br><span class="line">			Node *p;</span><br><span class="line">			Iterator (Node *);</span><br><span class="line">			public:</span><br><span class="line">			...</span><br><span class="line">			friend class List; // List has access to all members of Iterator</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Now list can still create Iterator, but client can only create Iterator by calling begin&#x2F;end.<br>Give your classes as few friends as possible.</p>
<ul>
<li>cuz this weakens encapsulation</li>
</ul>
<p>Providing <strong>access to private fields</strong>:<br>accessor&#x2F;mutator methods</p>
<ul>
<li>invariants is protected</li>
<li>the methods are gatekeeper, make sure the client follow the rules<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Vec&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">	int getX()const&#123;return x;&#125;</span><br><span class="line">	void setY(int z)&#123; y = z;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>What about <code>operator &lt;&lt;</code>, which need x and y but can’t be a member(you would have to put <code>cout</code> second to make it a member)?</p>
<ul>
<li>If <code>getX()</code>, <code>getY()</code> defined, we are fine</li>
<li>If not, make <code>operator &lt;&lt;</code> a friend function</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Vec&#123;</span><br><span class="line">	...</span><br><span class="line">	friend ostream &amp; operator&lt;&lt; (ostream &amp;out, const Vec &amp;v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream &amp;out, const Vec &amp;v)&#123;</span><br><span class="line">	return out &lt;&lt; v.x &lt;&lt; &#x27;&#x27; &lt;&lt; v.y &lt;&lt; endl;</span><br><span class="line">&#125; //can access vec field</span><br></pre></td></tr></table></figure>

<h2 id="Equality-Revisited"><a href="#Equality-Revisited" class="headerlink" title="Equality Revisited"></a>Equality Revisited</h2><p>Suppose we want to add a <code>length()</code> method to <code>List</code> , how should we implement it?<br>Options:</p>
<ol>
<li>loop through the nodes and count them (like <code>strlen</code>)—O(n)</li>
<li>store the length as a field of <code>List</code> and keep it up to date—O(1) length with negligible additional cost. This is generally preferred.</li>
</ol>
<p>Now consider again the spaceship operator <code>&lt;=&gt;</code> in the special case of equality checking:<br><code>l1 == l2</code>translates to <code>(l1 &lt;=&gt; l2) == 0</code><br>What is the cost of spaceship on 2 lists?</p>
<ul>
<li>O(n), which n is the length of the shorter list.</li>
<li>BUT, in the special case of equality checking, we are missing out the shortcut: lists with different lengths can’t be equal. In that case, could answer “not equal” in O(1) time</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class List&#123;</span><br><span class="line">	...</span><br><span class="line">	Node *theList();</span><br><span class="line">	public:</span><br><span class="line">	auto operator&lt;=&gt;(const List &amp;other)const &#123;</span><br><span class="line">		if(!theList &amp;&amp; !other.theList) return std::strong::ordering:: equal;</span><br><span class="line">		if(!theList) return std::strong::ordering:: less;</span><br><span class="line">		if (!other.theList) return std::strong::ordering:: greater;</span><br><span class="line">		</span><br><span class="line">		return theList &lt;=&gt; other.theList; //inappropriate, comparing ptrs</span><br><span class="line">		return *theList &lt;=&gt; *other.theList;</span><br><span class="line">	&#125;</span><br><span class="line">	//Different from previous implementation of `&lt;=&gt;`, </span><br><span class="line">	//cuz now we have empty list still an object.</span><br><span class="line"></span><br><span class="line">	bool operator == (const List &amp;other) const&#123;</span><br><span class="line">	if (length != other.length) return false;</span><br><span class="line">	return (*this &lt;=&gt; other) == 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Operator <code>&lt;=&gt;</code> automatically implements all 6 rational operators, but if you write operator <code>==</code> separately, the compiler will use that for <code>==</code> and <code>!=</code> instead of <code>&lt;=&gt;</code>, which lets you optimize equality classes, if possible.</p>
<h2 id="System-Modelling"><a href="#System-Modelling" class="headerlink" title="System Modelling"></a>System Modelling</h2><p>We’re gonna talk about how to describe the systems we are writing.<br>Visualize the structure of the system(abstractions + relationships among them) to aid design implementations.</p>
<h3 id="Popular-standard-UML-Unified-Modelling-Language"><a href="#Popular-standard-UML-Unified-Modelling-Language" class="headerlink" title="Popular standard: UML (Unified Modelling Language)"></a>Popular standard: UML (Unified Modelling Language)</h3><p><strong>Modelling classes:</strong><br>Name: <code>Vec</code><br>Fields(optional) :<br><code>x: integer</code><br><code>y: integer</code><br>Methods(optional):<br><code>+getX: integer</code><br><code>+getY: integer</code></p>
<p>(Visibility:<br>-private<br>+public)</p>
<p><strong>Relationship: Composition of Classes</strong><br>Recall </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Basis&#123;</span><br><span class="line">	Vec v1, v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Embedding one class(<code>Vec</code>) inside another(<code>Basis</code>) is called composition.</li>
<li>A Basis is composed of 2 vecs. They are part of a basis and that is their only purpose.</li>
<li>Relationship: A Basis owns a Vec(in fact, it owns 2 of them). <strong>OWNERSHIP</strong></li>
</ul>
<p>If A owns a B, then typically, </p>
<ul>
<li>B has no identity outside A(no independent existence)</li>
<li>If A is destroyed, B is destroyed</li>
<li>If A is copied, B is copied (deep copy)</li>
</ul>
<p>Eg: A car owns its engine, the engine is part of the car</p>
<ul>
<li>destroy the car -&gt; destroy the engine</li>
<li>copy the car -&gt; copy the engine<br>Implementation - usually as <strong>composition</strong> of classes: owns-a relationship</li>
</ul>
<p>Modelling:<br><strong>Aggregation</strong>: has-a relationship<br>similar to composition, except instead of one class being embedded in another, it’s rather linked to the other.<br>A <strong>has</strong> a B:</p>
<ul>
<li>B exists apart from its association with A</li>
<li>If A is destroyed, B lives on</li>
<li>If A is copied, B is not (Shallow copy)<ul>
<li>copies of A might share the same B</li>
</ul>
</li>
</ul>
<p>Typical implementation:<br>pointer fields.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Ponds &#123;</span><br><span class="line">	Duck *ducks[MaxDucks];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://w284.github.io">Winnie.zwl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://w284.github.io/winnie/bda9ad51.html">https://w284.github.io/winnie/bda9ad51.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/course-notes-24Fall/">course notes-24Fall</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_chair.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="next-post pull-full" href="/winnie/2d6afe5d.html" title="手记"><img class="cover" src="https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_front.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">手记</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="https://cdn.statically.io/gh/w284/pictures/main/img/avatar_.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Winnie.zwl</div><div class="author-info-description">Good morning, good afternoon, good night :)</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="mailto:winnie220284@gmail.com"><i></i><span>Email Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/w284" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:winnie220284@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.instagram.com/winniez8/" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/wenling-zou-655144232/" target="_blank" title="Linkedin"><i class="fab fa-linkedin-in" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Aloha, this is Winnie's blog, welcome ( ¨̮ ) ! I am a second-year math student @ university of waterloo. I post some of my course notes and other things that are worth-sharing here!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Class1-2"><span class="toc-number">1.</span> <span class="toc-text">Class1&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Intro-to-C"><span class="toc-number">1.1.</span> <span class="toc-text">Intro to C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Input-Output"><span class="toc-number">1.2.</span> <span class="toc-text">Input&#x2F;Output</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Formatted-Output"><span class="toc-number">1.3.</span> <span class="toc-text">Formatted Output</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class2"><span class="toc-number">2.</span> <span class="toc-text">Class2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">2.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-operations"><span class="toc-number">2.2.</span> <span class="toc-text">String operations:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Streams"><span class="toc-number">2.3.</span> <span class="toc-text">File Streams:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-3"><span class="toc-number">3.</span> <span class="toc-text">Class 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Stream"><span class="toc-number">3.1.</span> <span class="toc-text">String Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Application-processing-the-command-line"><span class="toc-number">3.2.</span> <span class="toc-text">Application: processing the command line</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Default-Function-Parameters"><span class="toc-number">3.3.</span> <span class="toc-text">Default Function Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overloading"><span class="toc-number">3.4.</span> <span class="toc-text">Overloading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#structs"><span class="toc-number">3.5.</span> <span class="toc-text">structs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constants"><span class="toc-number">3.6.</span> <span class="toc-text">Constants</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-4"><span class="toc-number">4.</span> <span class="toc-text">Class 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Constants-1"><span class="toc-number">4.1.</span> <span class="toc-text">Constants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parameter-Passing"><span class="toc-number">4.2.</span> <span class="toc-text">Parameter Passing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">4.3.</span> <span class="toc-text">Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-you-can-do"><span class="toc-number">4.3.1.</span> <span class="toc-text">What you can do:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Memory"><span class="toc-number">4.4.</span> <span class="toc-text">Dynamic Memory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-5"><span class="toc-number">5.</span> <span class="toc-text">Class 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Memory-Recall"><span class="toc-number">5.1.</span> <span class="toc-text">Dynamic Memory Recall:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Returning-Values-From-Functions"><span class="toc-number">5.2.</span> <span class="toc-text">Returning Values From Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Correct-Way"><span class="toc-number">5.2.1.</span> <span class="toc-text">Correct Way</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operator-Overloading"><span class="toc-number">5.3.</span> <span class="toc-text">Operator Overloading:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-6"><span class="toc-number">6.</span> <span class="toc-text">Class 6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Modules-and-Separate-Compilation"><span class="toc-number">6.1.</span> <span class="toc-text">Modules and Separate Compilation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classes"><span class="toc-number">6.2.</span> <span class="toc-text">Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Special-Purpose-Class-Methods-Big-5"><span class="toc-number">6.3.</span> <span class="toc-text">Special-Purpose Class Methods(Big 5):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constructors-initial-objects"><span class="toc-number">6.4.</span> <span class="toc-text">Constructors(initial objects)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Member-Initialization-Lists-MIL"><span class="toc-number">6.5.</span> <span class="toc-text">Member Initialization Lists (MIL)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-7"><span class="toc-number">7.</span> <span class="toc-text">Class 7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-Constructors"><span class="toc-number">7.1.</span> <span class="toc-text">Copy Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Custome-copy-ctor"><span class="toc-number">7.1.1.</span> <span class="toc-text">Custome copy ctor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deep-Copy"><span class="toc-number">7.1.2.</span> <span class="toc-text">Deep Copy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conversion-constructor"><span class="toc-number">7.2.</span> <span class="toc-text">Conversion constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Destructors"><span class="toc-number">7.3.</span> <span class="toc-text">Destructors</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-8"><span class="toc-number">8.</span> <span class="toc-text">Class 8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-Assignment-Operator"><span class="toc-number">8.1.</span> <span class="toc-text">Copy Assignment Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rvalues-Rvalues-References"><span class="toc-number">8.2.</span> <span class="toc-text">Rvalues &amp; Rvalues References</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-introduced-rvalue-reference"><span class="toc-number">8.2.1.</span> <span class="toc-text">C++ -11 introduced rvalue reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Move-Assignment-Operator"><span class="toc-number">8.3.</span> <span class="toc-text">Move Assignment Operator:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary-Rule-of-5-Big-5"><span class="toc-number">8.4.</span> <span class="toc-text">Summary: Rule of 5(Big 5)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-9"><span class="toc-number">9.</span> <span class="toc-text">Class 9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-Move-Elision"><span class="toc-number">9.1.</span> <span class="toc-text">Copy&#x2F;Move Elision</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Member-Operators"><span class="toc-number">9.2.</span> <span class="toc-text">Member Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-operators"><span class="toc-number">9.3.</span> <span class="toc-text">I&#x2F;O operators:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-of-Objects"><span class="toc-number">9.4.</span> <span class="toc-text">Arrays of Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Const-Objects"><span class="toc-number">9.5.</span> <span class="toc-text">Const Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparing-Objects"><span class="toc-number">9.6.</span> <span class="toc-text">Comparing Objects</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-10"><span class="toc-number">10.</span> <span class="toc-text">Class 10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparing-Objects-continued"><span class="toc-number">10.1.</span> <span class="toc-text">Comparing Objects(continued)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invariants-and-Encapsulation"><span class="toc-number">10.2.</span> <span class="toc-text">Invariants and Encapsulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-Design-Pattern"><span class="toc-number">10.3.</span> <span class="toc-text">Introduction to Design Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-Pattern"><span class="toc-number">10.4.</span> <span class="toc-text">Iterator Pattern:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Encapsulation-Continued"><span class="toc-number">10.5.</span> <span class="toc-text">Encapsulation Continued</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-11"><span class="toc-number">11.</span> <span class="toc-text">Class 11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Encapsulation-continued"><span class="toc-number">11.1.</span> <span class="toc-text">Encapsulation continued</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equality-Revisited"><span class="toc-number">11.2.</span> <span class="toc-text">Equality Revisited</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Modelling"><span class="toc-number">11.3.</span> <span class="toc-text">System Modelling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Popular-standard-UML-Unified-Modelling-Language"><span class="toc-number">11.3.1.</span> <span class="toc-text">Popular standard: UML (Unified Modelling Language)</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.statically.io/gh/w284/pictures/main/img/cat_under_chair.JPG);"><div id="footer-wrap"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hakuna matata</div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

const triggerPjaxFn = (val) => {
  if (!val) return
  Object.values(val).forEach(fn => { fn() })
}

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjaxSendOnce')
  btf.removeGlobalFnEvent('themeChange')

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  triggerPjaxFn(window.globalFn.pjaxSend)
})

document.addEventListener('pjax:complete', () => {
  btf.removeGlobalFnEvent('pjaxCompleteOnce')
  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  triggerPjaxFn(window.globalFn.pjaxComplete)
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>